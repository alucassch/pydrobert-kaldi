diff --git src/Makefile src/Makefile
index 7589477..de2b7e2 100644
--- src/Makefile
+++ src/Makefile
@@ -88,15 +88,15 @@ kaldi.mk:
 ext: test_dependencies ext_depend $(SUBDIRS) $(EXT_SUBDIRS)
 	-echo Done
 
-ifndef OPENFST_VER
-$(error Please rerun configure: OPENFST_VER is not defined, likely kaldi.mk was produced by older configure script.)
-endif
-# Note: OPENFST_VER is determined by configure and added to kaldi.mk
-OPENFST_VER_NUM := $(shell echo $(OPENFST_VER) | sed 's/\./ /g' | xargs printf "%d%02d%02d")
+# ifndef OPENFST_VER
+# $(error Please rerun configure: OPENFST_VER is not defined, likely kaldi.mk was produced by older configure script.)
+# endif
+# # Note: OPENFST_VER is determined by configure and added to kaldi.mk
+# OPENFST_VER_NUM := $(shell echo $(OPENFST_VER) | sed 's/\./ /g' | xargs printf "%d%02d%02d")
 test_dependencies:
-ifeq ("$(shell expr $(OPENFST_VER_NUM) \< 10302)","1")
-	$(error OpenFst $(OPENFST_VER) is not supported. You now need OpenFst >= 1.3.2.)
-endif
+# ifeq ("$(shell expr $(OPENFST_VER_NUM) \< 10302)","1")
+# 	$(error OpenFst $(OPENFST_VER) is not supported. You now need OpenFst >= 1.3.2.)
+# endif
 
 check_portaudio:
 	@[ -d ../tools/portaudio ] || ( cd ../tools;  ./install_portaudio.sh )
@@ -154,7 +154,7 @@ base:
 matrix : base
 thread : base
 util: base matrix thread
-feat: base matrix util gmm transform tree thread
+feat: base matrix util thread
 tree: base util matrix
 optimization: base matrix
 gmm: base util matrix tree thread
@@ -179,3 +179,12 @@ online: decoder gmm transform feat matrix util base lat hmm thread tree
 online2: decoder gmm transform feat matrix util base lat hmm thread ivector cudamatrix nnet2 nnet3
 kws: base util hmm tree matrix lat
 
+.PHONY: kaldi_cxxflags kaldi_ldlibs kaldi_ldflags
+kaldi_cxxflags:
+	echo $(CXXFLAGS) > $@
+
+kaldi_ldlibs:
+	echo $(LDLIBS) > $@
+
+kaldi_ldflags:
+	echo $(LDFLAGS) > $@
diff --git src/base/kaldi-types.h src/base/kaldi-types.h
index 7ebf4f8..f4a8866 100644
--- src/base/kaldi-types.h
+++ src/base/kaldi-types.h
@@ -41,22 +41,21 @@ typedef float   BaseFloat;
 
 // for discussion on what to do if you need compile kaldi
 // without OpenFST, see the bottom of this this file
-#include <fst/types.h>
+// #include <fst/types.h>
 
-namespace kaldi {
-  using ::int16;
-  using ::int32;
-  using ::int64;
-  using ::uint16;
-  using ::uint32;
-  using ::uint64;
-  typedef float   float32;
-  typedef double double64;
-}  // end namespace kaldi
+// namespace kaldi {
+//   using ::int16;
+//   using ::int32;
+//   using ::int64;
+//   using ::uint16;
+//   using ::uint32;
+//   using ::uint64;
+//   typedef float   float32;
+//   typedef double double64;
+// }  // end namespace kaldi
 
 // In a theoretical case you decide compile Kaldi without the OpenFST
 // comment the previous namespace statement and uncomment the following
-/*
 namespace kaldi {
   typedef int8_t   int8;
   typedef int16_t  int16;
@@ -70,6 +69,5 @@ namespace kaldi {
   typedef float    float32;
   typedef double   double64;
 }  // end namespace kaldi
-*/
 
 #endif  // KALDI_BASE_KALDI_TYPES_H_
diff --git src/configure src/configure
index 6ee1f64..bc7202e 100755
--- src/configure
+++ src/configure
@@ -57,11 +57,6 @@ if ! [ -x "$PWD/configure" ]; then
   exit 1
 fi
 
-## Default locations for FST and linear algebra libraries.
-MATHLIB='ATLAS'
-ATLASROOT=`rel2abs ../tools/ATLAS/`
-FSTROOT=`rel2abs ../tools/openfst`
-
 # Avoid using any variables that are set in the shell.
 unset MKLROOT
 unset CLAPACKROOT
@@ -79,7 +74,7 @@ threaded_atlas=false #  By default, use the un-threaded version of ATLAS.
 threaded_math=${threaded_atlas}
 static_math=false
 static_fst=false
-use_cuda=true
+use_cuda=false
 dynamic_kaldi=false
 mkl_threading=sequential
 
@@ -186,11 +181,6 @@ do
   esac
 done
 
-# the idea here is that if you change the configuration options from using
-# CUDA to not using it, or vice versa, we want to recompile all parts of the
-# code that may use a GPU.  Touching this file is a way to force this.
-touch cudamatrix/cu-common.h 2>/dev/null
-
 function failure {
   echo "***configure failed: $* ***" >&2
   if [ -f kaldi.mk ]; then rm kaldi.mk; fi
@@ -235,8 +225,6 @@ function exit_success {
   exit 0;
 }
 
-
-
 function check_library {
   local libpath=$1
   local libname=$2
@@ -247,266 +235,8 @@ function check_library {
   return 1
 }
 
-
-
-#Check if at least one of these variables is set
-#If yes, we want to switch to using the MKL
-is_set $MKLLIBDIR && echo "Force-configuring KALDI to use MKL" && export MATHLIB="MKL"
-is_set $MKLROOT && echo "Force-configuring KALDI to use MKL"&& export MATHLIB="MKL"
-is_set $CLAPACKROOT && echo "Force-configuring KALDI to use CLAPACK"&& export MATHLIB="CLAPACK"
 is_set $OPENBLASROOT && echo "Force-configuring KALDI to use OPENBLAS"&& export MATHLIB="OPENBLAS"
 
-#MKL functions
-function linux_configure_mkllibdir {
-  local mklroot=$1
-
-  if [ -d $mklroot/lib/em64t ]; then
-    echo $mklroot/lib/em64t
-  elif [ -d $mklroot/lib/intel64 ]; then
-    echo $mklroot/lib/intel64
-  else
-    return 1;
-  fi
-}
-
-function linux_configure_mkl_includes {
-  test -d $1/include && echo "$1/include" && return;
-  test -d $2/../../include && echo "$2/../../include" && return;
-  failure "Could not find the MKL include directory"
-}
-
-
-function linux_configure_mkl_libraries {
-  local mkllibdir=$1
-  local static=$2
-  local threaded=$3
-  local mplib=$4
-
-  declare -A mkl_libs
-  mkl_libs=(
-    [sequential]="mkl_intel_lp64 mkl_core mkl_sequential"
-    [gomp]="mkl_intel_lp64 mkl_core mkl_gnu_thread"
-    [iomp]="mkl_intel_lp64 mkl_core mkl_intel_thread "
-    [tbb]="mkl_intel_lp64 mkl_core mkl_tbb_thread "
-  )
-
-  if [ -z "${mkl_libs[$threaded]}" ]; then
-    echo >&2 "Unknown threading mode: $threaded"
-    return 1;
-  fi
-
-  local linkline=""
-  if  ! $static ; then
-    linkline="-L$mkllibdir -Wl,-rpath=$mkllibdir"
-    for file in ${mkl_libs[$threaded]}; do
-      local libfile=$mkllibdir/lib$file.so
-      check_exists $libfile
-      linkline+=" -l$file "
-    done
-  else
-    if [ $threaded == "sequential" ] ; then
-      test -f "$mkllibdir/libmkl_solver_lp64.a" && \
-        linkline="$linkline $mkllibdir/libmkl_solver_lp64.a"
-    else
-      test -f "$mkllibdir/libmkl_solver_lp64_sequential.a" && \
-        linkline="$linkline $mkllibdir/libmkl_solver_lp64_sequential.a"
-    fi
-    linkline="$linkline -Wl,--start-group"
-    for file in ${mkl_libs[$threaded]}; do
-      local libfile=$mkllibdir/lib${file}.a
-      check_exists $libfile
-      linkline="$linkline $libfile"
-    done
-    linkline="$linkline -Wl,--end-group "
-  fi
-  echo "$linkline"
-}
-
-function linux_configure_mkl_extra {
-  local static=$1
-  local threaded=$2
-
-  declare -A extra_libs
-  extra_libs=(
-    [sequential]="-lpthread -lm"
-    [gomp]="-lgomp -ldl -lpthread -lm"
-    [iomp]="-ldl -lpthread -lm"
-    [tbb]=" -ldl -lpthread -lm "
-  )
-  echo "$linkline ${extra_libs[$threaded]}"
-}
-
-function linux_configure_threadinglibdir {
-  local library=$1
-  local mklroot=$2
-  local mkllibdir=$3
-  local libexts=$4
-
-  ##First we try to use the library in the same directory
-  ##where the mkl libraries reside
-  ##Afterwards, just try some possibilities for different MKL layouts
-  for libext in $libexts; do
-    check_library $mkllibdir "lib$library" $libext \
-    && echo `readlink -f $mkllibdir` && return 0
-
-    local testdir=`(cd $mklroot; cd ..; cd lib/intel64;pwd)`
-    test -d $testdir && check_library $testdir "lib$library" $libext && echo `readlink -f $testdir` && return 0;
-    local testdir=`(cd $mklroot; cd ..; cd lib/em64t;pwd)`
-    test -d $testdir && check_library $testdir "lib$library" $libext && echo `readlink -f $testdir` && return 0;
-
-    local testdir=`(cd $mkllibdir; cd ../../..; cd lib/intel64;pwd)`
-    test -d $testdir && check_library $testdir "lib$library" $libext && echo `readlink -f $testdir` && return 0;
-    local testdir=`(cd $mklroot; cd ../../..; cd lib/em64t;pwd)`
-    test -d $testdir && check_library $testdir "lib$library" $libext && echo `readlink -f $testdir` && return 0;
-  done
-
-  #failure "Could not find the library iomp5, use the configure switch --omp-libdir"
-  return 1
-}
-
-function linux_configure_mkl_threading {
-  local mklroot=$1
-  local mkllibdir=$2
-  local static=$3
-  local threading=$4
-
-  declare -A libs
-  libs=(
-    [sequential]=""
-    [gomp]=""
-    [iomp]="iomp5"
-    [tbb]="tbb"
-  )
-
-  echo >&2 "Configuring MKL threading as $threading"
-  library=${libs[$threading]}
-  if [ -z "$library" ]; then
-    return 0
-  fi
-
-  if ! is_set $OMPLIBDIR ; then
-    if  $static ; then
-      OMPLIBDIR=`linux_configure_threadinglibdir $library "$MKLROOT" "$MKLLIBDIR" "a"`
-    else
-      OMPLIBDIR=`linux_configure_threadinglibdir $library "$MKLROOT" "$MKLLIBDIR" "so"`
-    fi
-  fi
-
-  check_library $OMPLIBDIR "lib$library" "a" || \
-  check_library $OMPLIBDIR "lib$library" "so" || \
-  failure "Could not find the $library library, have your tried the --omp-libdir switch?"
-
-  OMP_LINK_LINE=''
-  # TODO(arnab): in the following conditional, the $static_math test is
-  # needed since the OpenMP library is assumed to be dynamic.
-  if [ "$OMPLIBDIR" != "$MKLLIBDIR" ] ; then
-    OMP_LINK_LINE="-L${OMPLIBDIR}"
-  fi
-  #if the libiomp5 library is dynamic, we add the rpath attribute
-  if ! $static_math ; then
-    OMP_LINK_LINE="$OMP_LINK_LINE -Wl,-rpath=$OMPLIBDIR -l$library"
-  else
-    OMP_LINK_LINE="$OMP_LINK_LINE -Wl,-Bstatic -l$library -Wl,-Bdynamic"
-  fi
-  echo "$OMP_LINK_LINE"
-}
-
-##
-## CUDA is used only in selected directories including src/cudamatrix, src/nnet*
-## and src/chain*.  It is used to accelerate the neural network training, the
-## rest of kaldi runs on CPUs.
-##
-function configure_cuda {
-  #check for CUDA toolkit in the system
-  if [ ! -d  "$CUDATKDIR" ]; then
-    for base in /Developer/NVIDIA/CUDA-6.0 /usr/local/share/cuda /usr/local/cuda /pkgs_local/cuda-3.2/ /opt/nvidia_cuda/cuda-6.0/ /usr/; do
-      if [ -f $base/bin/nvcc ]; then
-        CUDATKDIR=$base
-      fi
-    done
-  fi
-
-  if [ -d "$CUDATKDIR" ]; then
-    if [ ! -f $CUDATKDIR/bin/nvcc ]; then
-      failure "Cannnot find nvcc in CUDATKDIR=$CUDATKDIR"
-    fi
-    echo "Using CUDA toolkit $CUDATKDIR (nvcc compiler and runtime libraries)"
-    echo >> kaldi.mk
-    echo "#Next section enables CUDA for compilation" >> kaldi.mk
-    echo CUDA = true >> kaldi.mk
-    echo CUDATKDIR = $CUDATKDIR >> kaldi.mk
-
-    # Determine 'CUDA_ARCH',
-    CUDA_VERSION=$($CUDATKDIR/bin/nvcc -V | tr '.,' '_ ' | awk '/release/{sub(/.*release/,""); print $1;}') # MAJOR_MINOR,
-    if [ -z "$CUDA_VERSION" ] ; then
-      echo "Cannot figure out CUDA_VERSION from the nvcc output. Either your CUDA is too new or too old."
-      exit 1
-    fi
-
-    case $CUDA_VERSION in
-      5_5) CUDA_ARCH="-gencode arch=compute_13,code=sm_13 -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35" ;;
-      6_*) CUDA_ARCH="-gencode arch=compute_13,code=sm_13 -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_50,code=sm_50" ;;
-      7_*) CUDA_ARCH="-gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_53,code=sm_53" ;;
-      *) echo "Unsupported CUDA_VERSION (CUDA_VERSION=$CUDA_VERSION), please report it to Kaldi mailing list, together with 'nvcc -h' or 'ptxas -h' which lists allowed -gencode values..."; exit 1 ;;
-    esac
-    echo "CUDA_ARCH = $CUDA_ARCH" >> kaldi.mk
-
-    # 64bit/32bit?
-    if [ "`uname -m`" == "x86_64" ]; then
-      if [ "`uname`" == "Darwin" ]; then
-        sed 's/lib64/lib/g' < makefiles/cuda_64bit.mk >> kaldi.mk
-      else
-        cat makefiles/cuda_64bit.mk >> kaldi.mk
-      fi
-    else
-      cat makefiles/cuda_32bit.mk >> kaldi.mk
-    fi
-
-  else
-    echo "CUDA will not be used! If you have already installed cuda drivers "
-    echo "and cuda toolkit, try using --cudatk-dir=... option.  Note: this is"
-    echo "only relevant for neural net experiments"
-  fi
-}
-
-function linux_configure_speex {
-  #check whether the user has called tools/extras/install_speex.sh or not
-  [ ! -z "$SPEEXROOT" ] || SPEEXROOT=`pwd`/../tools/speex
-  [ ! -z "$SPEEXLIBDIR" ] || SPEEXLIBDIR="$SPEEXROOT"/lib
-  [ ! -z "$SPEEXINCLUDEDIR" ] || SPEEXINCLUDEDIR="$SPEEXROOT"/include
-  static_speex=$1
-  if [ "foo"$static_speex == "foo" ]; then
-    static_speex=false
-  fi
-
-  if $static_speex; then
-    spx_type=a
-  else
-    spx_type=so
-  fi
-  if [ ! -f "$SPEEXLIBDIR/libspeex.${spx_type}" ];then
-    echo "Info: configuring Kaldi not to link with Speex (don't worry, it's only needed if you"
-    echo "intend to use 'compress-uncompress-speex', which is very unlikely)"
-    return
-  fi
-
-  if [ -f $SPEEXINCLUDEDIR/speex/speex.h ]; then
-    echo >> kaldi.mk
-    echo CXXFLAGS += -DHAVE_SPEEX -I${SPEEXINCLUDEDIR} >> kaldi.mk
-
-    if $static_speex; then
-      echo LDLIBS += $SPEEXLIBDIR/libspeex.a
-    else
-      echo LDLIBS += -L${SPEEXLIBDIR} -lspeex >> kaldi.mk
-      echo LDFLAGS += -Wl,-rpath=${SPEEXLIBDIR} >> kaldi.mk
-    fi
-
-    echo "Successfully configured with Speex at $SPEEXROOT, (static=[$static_speex])"
-  else
-    echo "Speex will not be used. If you want to use it, run tools/extras/install_speex.sh first."
-  fi
-}
-
 function fix_cxx_flag {
   CXXCOMPILER=`grep "CXX = " kaldi.mk | awk '{print $3}'`
   if [ $CXXCOMPILER=="g++" ]; then
@@ -516,282 +246,6 @@ function fix_cxx_flag {
   fi
 }
 
-function linux_atlas_failure { # function we use when we couldn't find
-   # ATLAS libs.
-   echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-   echo ATLASLIBS = [somewhere]/liblapack.a [somewhere]/libcblas.a [somewhere]/libatlas.a [somewhere]/libf77blas.a $ATLASLIBDIR >> kaldi.mk
-   cat makefiles/linux_atlas.mk >> kaldi.mk
-   fix_cxx_flag
-   echo "** $* ***"
-   echo "**  ERROR   **"
-   echo "** Configure cannot proceed automatically."
-   echo "**  If you know that you have ATLAS installed somewhere on your machine, you"
-   echo "** may be able to proceed by replacing [somewhere] in kaldi.mk with a directory."
-   echo "**  If you have sudo (root) access you could install the ATLAS package on your"
-   echo "** machine, e.g. 'sudo apt-get install libatlas-dev libatlas-base-dev' or"
-   echo "** 'sudo yum install atlas.x86_64' or 'sudo zypper install libatlas3-devel',"
-   echo "** or on cygwin, install atlas from the installer GUI; and then run ./configure"
-   echo "** again."
-   echo "**"
-   echo "**  Otherwise (or if you prefer OpenBLAS for speed), you could go the OpenBLAS"
-   echo "** route: cd to ../tools, type 'extras/install_openblas.sh', cd back to here,"
-   echo "** and type './configure  --openblas-root=../tools/OpenBLAS/install'"
-   exit 1;
-}
-
-function linux_check_static {
-  # will exit with success if $dir seems to contain ATLAS libraries with
-  # right architecture (compatible with default "nm")
-  echo "int main(void) { return 0; }" > test_linking.cc;
-  if [ -f $dir/libatlas.a ]; then # candidate...
-    # Note: on the next line, the variable assignment
-    # LANG=en_US should apply just to the program called on that line.
-    if LANG=en_US gcc -o test_linking test_linking.cc -u ATL_flushcache $dir/libatlas.a 2>&1 | grep -i "incompatible" >/dev/null; then
-      echo "Directory $dir may contain ATLAS libraries but seems to be wrong architecture";
-      rm test_linking test_linking.cc 2>/dev/null
-      return 1;
-    fi
-    rm test_linking test_linking.cc 2>/dev/null
-    return 0;
-  else
-    rm test_linking.cc
-    return 1;
-  fi
-}
-
-function linux_configure_debian_ubuntu {
-  m=$1
-  ATLASLIBS="/usr/lib$m/atlas-base/libatlas.so.3gf  /usr/lib$m/atlas-base/libf77blas.so.3gf /usr/lib$m/atlas-base/libcblas.so.3gf  /usr/lib$m/atlas-base/liblapack_atlas.so.3gf"
-  for f in $ATLASLIBS; do
-    [ ! -f $f ] && return 1;
-  done
-  lapacklib=$(echo $ATLASLIBS | awk '{print $NF}')
-  if ! nm --dynamic $lapacklib | grep ATL_cgetrf >/dev/null; then
-    exit 1;
-  fi
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS >> kaldi.mk
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  echo "Successfully configured for Debian/Ubuntu Linux [dynamic libraries] with ATLASLIBS =$ATLASLIBS"
-  $use_cuda && configure_cuda
-  linux_configure_speex
-  exit_success;
-}
-
-function linux_configure_debian_ubuntu3 {
-  ATLASLIBS="/usr/lib/libatlas.so.3  /usr/lib/libf77blas.so.3 /usr/lib/libcblas.so.3  /usr/lib/liblapack_atlas.so.3"
-  for f in $ATLASLIBS; do
-    [ ! -f $f ] && return 1;
-  done
-  lapacklib=$(echo $ATLASLIBS | awk '{print $NF}')
-  if ! nm --dynamic $lapacklib | grep ATL_cgetrf >/dev/null; then
-    exit 1;
-  fi
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS >> kaldi.mk
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  echo "Successfully configured for Debian/Ubuntu Linux [dynamic libraries] with ATLASLIBS =$ATLASLIBS"
-  $use_cuda && configure_cuda
-  linux_configure_speex
-  exit_success;
-}
-
-function linux_configure_debian7 {
-  ATLASLIBS="/usr/lib/atlas-base/libatlas.so.3.0 /usr/lib/atlas-base/libf77blas.so.3.0 /usr/lib/atlas-base/libcblas.so.3 /usr/lib/atlas-base/liblapack_atlas.so.3"
-  for f in $ATLASLIBS; do
-    [ ! -f $f ] && return 1;
-  done
-  lapacklib=$(echo $ATLASLIBS | awk '{print $NF}')
-  if ! nm --dynamic $lapacklib | grep ATL_cgetrf >/dev/null; then
-    exit 1;
-  fi
-  libdir=$(dirname $(echo $ATLASLIBS | awk '{print $1}'))
-  [ -z "$libdir" ] && echo "Error getting libdir in linux_configure_debian7" && exit 1;
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS -Wl,-rpath=$libdir >> kaldi.mk
-  echo
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  echo "Successfully configured for Debian 7 [dynamic libraries] with ATLASLIBS =$ATLASLIBS"
-  $use_cuda && configure_cuda
-  linux_configure_speex
-  exit_success;
-}
-
-function linux_configure_redhat {
-  m=$1  # 64 or empty.
-  ATLASLIBS="/usr/lib$m/atlas/libatlas.so.3 /usr/lib$m/atlas/libf77blas.so.3 /usr/lib$m/atlas/libcblas.so.3 /usr/lib$m/atlas/libclapack.so.3"
-  for f in $ATLASLIBS; do
-    [ ! -f $f ] && return 1;
-  done
-  libdir=$(dirname $(echo $ATLASLIBS | awk '{print $1}'))
-  [ -z "$libdir" ] && echo "Error getting libdir in linux_configure_redhat" && exit 1;
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS -Wl,-rpath=$libdir >> kaldi.mk
-  echo
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  echo "Successfully configured for red hat [dynamic libraries] with ATLASLIBS =$ATLASLIBS"
-  $use_cuda && configure_cuda
-  exit_success;
-}
-
-function linux_configure_redhat_fat {
-  # This is for when only two so-called 'fat' ATLAS libs are provided:
-  # libsatlas.so.3 and libtatlas.so.3.
-  # See http://stackoverflow.com/questions/13439296/build-shared-libraries-in-atlas.
-  m=$1  # 64 or empty.
-  ATLASLIBS="/usr/lib$m/atlas/libsatlas.so.3 /usr/lib$m/atlas/libtatlas.so.3"
-  for f in $ATLASLIBS; do
-    [ ! -f $f ] && return 1;
-  done
-  libdir=$(dirname $(echo $ATLASLIBS | awk '{print $1}'))
-  [ -z "$libdir" ] && echo "Error getting libdir in linux_configure_redhat_fat" && exit 1;
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS -Wl,-rpath=$libdir >> kaldi.mk
-  echo
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  echo "Successfully configured for red hat [dynamic libraries, fat] with ATLASLIBS =$ATLASLIBS"
-  $use_cuda && configure_cuda
-  exit_success;
-}
-
-
-function linux_configure_static {
-  if $threaded_atlas; then pt=pt; else pt=""; fi
-
-  if [ -z $ATLASLIBDIR ]; then # Note: it'll pick up the last one below.
-    for dir in /usr{,/local}/lib{64,}{,/atlas,/atlas-sse2,/atlas-sse3} \
-       /usr/local/atlas/lib{,64} `pwd`/../tools/ATLAS/build/install/lib/ $ATLASROOT/lib; do
-     linux_check_static &&  ATLASLIBDIR=$dir
-    done
-    if [ -z $ATLASLIBDIR ]; then # Note: it'll pick up the last one below.
-      echo "Could not find libatlas.a in any of the generic-Linux places, but we'll try other stuff..."
-      return 1;
-    fi
-  elif [ ! -f $ATLASLIBDIR/libatlas.a ]; then
-    echo "Could not find libatlas.a in '$ATLASLIBDIR'"
-    return 1;
-  fi
-  echo "Validating presence of ATLAS libs in $ATLASLIBDIR"
-  ATLASLIBS=
-  # The Lapack part of ATLAS seems to appear under various different names.. but it
-  # should always have symbols like ATL_cgetrf defined, so we test for this,
-  # for all the names we have encountered.
-  for libname in liblapack liblapack_atlas  libclapack; do
-    if [ -f $ATLASLIBDIR/${libname}.a -a "$ATLASLIBS" == "" ]; then
-      if nm  $ATLASLIBDIR/${libname}.a  | grep ATL_cgetrf >/dev/null; then
-         ATLASLIBS=$ATLASLIBDIR/${libname}.a
-         echo "Using library $ATLASLIBS as ATLAS's CLAPACK library."
-      fi
-    fi
-  done
-  if [ "$ATLASLIBS" == "" ]; then
-    echo Could not find any libraries $ATLASLIBDIR/{liblapack,liblapack_atlas,libclapack} that seem to be an ATLAS CLAPACK library.
-    return ;
-  fi
-
-  for x in lib${pt}cblas.a libatlas.a lib${pt}f77blas.a; do
-    if [ ! -f $ATLASLIBDIR/$x ]; then
-      echo "Configuring static ATLAS libraries failed: Could not find library $x in directory $ATLASLIBDIR"
-      return 1;
-    fi
-    ATLASLIBS="$ATLASLIBS $ATLASLIBDIR/$x"
-  done
-  if $threaded_atlas; then ATLASLIBS="$ATLASLIBS"; fi
-
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS >> kaldi.mk
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  $use_cuda && configure_cuda
-  linux_configure_speex
-  echo "Successfully configured for Linux [static libraries] with ATLASLIBS =$ATLASLIBS"
-  exit_success;
-}
-
-function linux_check_dynamic {
-  # will exit with success if $dir seems to contain ATLAS libraries with
-  # right architecture (compatible with default "nm")
-  if $threaded_atlas; then pt=t; else pt=s; fi
-  for atlas_libname in libatlas.so lib${pt}atlas.so; do
-    if [ -f $dir/$atlas_libname ]; then # candidate...
-      if nm --dynamic $dir/$atlas_libname 2>&1 | grep "File format not recognized" >/dev/null; then
-        echo "Directory $dir may contain dynamic ATLAS libraries but seems to be wrong architecture";
-        return 1;
-      fi
-        echo "Atlas found in $dir";
-        return 0;
-      fi
-  done
-  # echo "... no {libatlas,lib${pt}atlas}.so in $dir";
-  return 1;
-}
-
-function linux_configure_dynamic {
-  if $threaded_atlas; then pt=t; else pt=s; fi # relevant to "fat" libraries, will change later for separate ones
-  if [ -z $ATLASLIBDIR ]; then # Note: it'll pick up the last one below.
-    for dir in /usr{,/local}/lib{,64}{,/atlas,/atlas-sse2,/atlas-sse3} \
-      `pwd`/../tools/ATLAS/build/install/lib/ $ATLASROOT/lib; do
-      linux_check_dynamic && ATLASLIBDIR=$dir && ATLASLIBNAME=$atlas_libname
-    done
-    if [ -z $ATLASLIBDIR -o -z $ATLASLIBNAME ]; then
-      echo "Could not find {libatlas,lib${pt}atlas}.so in any of the obvious places, will most likely try static:"
-      return 1;
-    fi
-  fi
-
-  # If using "fat" libraries we only need one file to link against
-  if [ $ATLASLIBNAME != libatlas.so ]; then
-    if [ -f $ATLASLIBDIR/$ATLASLIBNAME ]; then
-      ATLASLIBS="$ATLASLIBDIR/$ATLASLIBNAME"
-    else
-      echo "Configuring dynamic ATLAS library failed: library $ATLASLIBNAME not found in $ATLASLIBDIR"
-      return 1;
-    fi
-  else  # with "thin" libraries, we have several object to link against, and different single/multi-thread names
-    if $threaded_atlas; then pt=pt; else pt=""; fi
-    echo "Validating presence of ATLAS libs in $ATLASLIBDIR"
-    ATLASLIBS=
-    # The Lapack part of ATLAS seems to appear under various different names.. but it
-    # should always have symbols like ATL_cgetrf defined, so we test for this,
-    # for all the names we have encountered.
-    for libname in lapack lapack_atlas  clapack; do
-      if [ -f $ATLASLIBDIR/lib${libname}.so -a "$ATLASLIBS" == "" ]; then
-        if nm  --dynamic $ATLASLIBDIR/lib${libname}.so  | grep ATL_cgetrf >/dev/null; then
-           ATLASLIBS="$ATLASLIBDIR/lib${libname}.so"
-           echo "Using library $ATLASLIBS as ATLAS's CLAPACK library."
-        fi
-      fi
-    done
-    if [ "$ATLASLIBS" == "" ]; then
-      echo Could not find any libraries $ATLASLIBDIR/{liblapack,liblapack_atlas,libclapack} that seem to be an ATLAS CLAPACK library.
-      return 1;
-    fi
-
-    for x in ${pt}cblas atlas ${pt}f77blas; do
-      if [ ! -f $ATLASLIBDIR/lib$x.so ]; then
-        echo "Configuring dynamic ATLAS libraries failed: Could not find library $x in directory $ATLASLIBDIR"
-        return 1;
-      fi
-      ATLASLIBS="$ATLASLIBS $ATLASLIBDIR/lib${x}.so"
-    done
-    if $threaded_atlas; then ATLASLIBS="$ATLASLIBS"; fi
-  fi
-
-  echo ATLASINC = $ATLASROOT/include >> kaldi.mk
-  echo ATLASLIBS = $ATLASLIBS >> kaldi.mk
-  cat makefiles/linux_atlas.mk >> kaldi.mk
-  fix_cxx_flag
-  $use_cuda && configure_cuda
-  linux_configure_speex
-  echo "Successfully configured for Linux [dynamic libraries] with ATLASLIBS =$ATLASLIBS"
-  exit_success;
-}
-
 echo "Configuring ..."
 
 if [ ! -f makefiles/common.mk ]; then
@@ -799,18 +253,18 @@ if [ ! -f makefiles/common.mk ]; then
 fi
 
 
-echo "Checking OpenFST library in $FSTROOT ..."
-if [ ! -f $FSTROOT/include/fst/fst.h  ]; then
-    failure "Could not find file $FSTROOT/include/fst/fst.h:
-    you may not have installed OpenFst.  See ../tools/INSTALL"
-fi
-echo Checking OpenFst library was patched.
-if ! grep "multiple repeated" $FSTROOT/include/fst/minimize.h >/dev/null; then
-    echo "**  ERROR  **"
-    echo "** $FSTROOT/include/fst/minimize.h seems not to be patched:"
-    echo "patch not applied?  FST tools will not work in our recipe."
-    exit 1;
-fi
+# echo "Checking OpenFST library in $FSTROOT ..."
+# if [ ! -f $FSTROOT/include/fst/fst.h  ]; then
+#     failure "Could not find file $FSTROOT/include/fst/fst.h:
+#     you may not have installed OpenFst.  See ../tools/INSTALL"
+# fi
+# echo Checking OpenFst library was patched.
+# if ! grep "multiple repeated" $FSTROOT/include/fst/minimize.h >/dev/null; then
+#     echo "**  ERROR  **"
+#     echo "** $FSTROOT/include/fst/minimize.h seems not to be patched:"
+#     echo "patch not applied?  FST tools will not work in our recipe."
+#     exit 1;
+# fi
 
 # back up the old one in case we modified it
 if [ -f kaldi.mk ]; then
@@ -821,23 +275,11 @@ fi
 printf "# This file was generated using the following command:\n# $cmd_line\n\n" > kaldi.mk
 cat makefiles/common.mk >> kaldi.mk
 if $dynamic_kaldi ; then
-KALDILIBDIR=`pwd`/lib
+KALDILIBDIR=${PREFIX}/lib
 echo "KALDI_FLAVOR := dynamic" >> kaldi.mk
 echo "KALDILIBDIR := $KALDILIBDIR" >> kaldi.mk
 fi
 echo "CONFIGURE_VERSION := $CONFIGURE_VERSION" >> kaldi.mk
-echo "FSTROOT = $FSTROOT" >> kaldi.mk
-
-# Check installed OpenFst version and add C++11 flags if OpenFst >= 1.4
-OPENFST_VER="${OPENFST_VER:-`grep 'PACKAGE_VERSION' $FSTROOT/Makefile | sed -e 's:.*= ::'`}"
-echo "OPENFST_VER = $OPENFST_VER" >> kaldi.mk
-OPENFST_VER_NUM=`echo $OPENFST_VER | sed 's/\./ /g' | xargs printf "%d%02d%02d"`
-if [ $OPENFST_VER_NUM -ge 10400 ]; then
-  echo "OPENFST_GE_10400 = 1" >> kaldi.mk
-  echo "EXTRA_CXXFLAGS += -DHAVE_OPENFST_GE_10400 -std=c++0x" >> kaldi.mk
-else
-  echo "OPENFST_GE_10400 = 0" >> kaldi.mk
-fi
 
 # Most of the OS-specific steps below will append to kaldi.mk
 echo "Doing OS specific configurations ..."
@@ -851,12 +293,14 @@ if [ "`uname`" == "Darwin"  ]; then
   if [ ! -e /System/Library/Frameworks/Accelerate.framework ]; then
     failure "Need the Accelerate.framework to compile on Darwin."
   fi
-  if [ ! -f $FSTROOT/lib/libfst.a ]; then
-    failure "Static OpenFST library not found:  See ../tools/INSTALL"
-  fi
   # posix_memalign and gcc -rdynamic options not present on OS X 10.5.*
   osx_ver=`sw_vers | grep ProductVersion | awk '{print $2}' | awk '{split($0,a,"\."); print a[1] "." a[2]; }'`
   echo "Configuring for OS X version $osx_ver ..."
+  osx_ver_major="${osx_ver%.*}"
+  osx_ver_minor="${osx_ver#*.}"
+  if [ $osx_ver_major -lt 10 ] || [ $osx_ver_minor -lt 5 ]; then
+    failure "OS X version '$osx_ver' not supported"
+  fi
   if [ "$osx_ver" == "10.5" ]; then
     check_exists makefiles/darwin_10_5.mk
     cat makefiles/darwin_10_5.mk >> kaldi.mk
@@ -875,11 +319,13 @@ if [ "`uname`" == "Darwin"  ]; then
   elif [ "$osx_ver" == "10.10" ]; then
     check_exists makefiles/darwin_10_10.mk
     cat makefiles/darwin_10_10.mk >> kaldi.mk
-  elif [ "$osx_ver" == "10.11" ]; then
+  else
+    echo \
+"Configured all OS X releases >= 10.11 to use the same Makefile.\n"\
+" If this stops working at some point in the future, please post an\n"\
+" issue on my GitHub repo (sdrobert)"
     check_exists makefiles/darwin_10_11.mk
     cat makefiles/darwin_10_11.mk >> kaldi.mk
-  else
-    failure "OS X version '$osx_ver' not supported"
   fi
   echo "Configuration succeeded for platform Darwin."
   exit_success;
@@ -899,141 +345,9 @@ if [ "`uname -o`" == "Cygwin"  ]; then
 fi
 
 if [ "`uname`" == "Linux" ]; then
-  if  $static_fst ; then
-      OPENFSTLIBS="$FSTROOT/lib/libfst.a"
-      fst_type='a'
-  else
-      OPENFSTLIBS="-L${FSTROOT}/lib -lfst"
-      OPENFSTLDFLAGS="-Wl,-rpath=${FSTROOT}/lib"
-      fst_type='so'
-  fi
-  if [ ! -f "$FSTROOT/lib/libfst.${fst_type}" ]; then
-    failure "Static=[$static_fst] OpenFST library not found:  See ../tools/INSTALL"
-  fi
-  echo OPENFSTLIBS = $OPENFSTLIBS >> kaldi.mk
-  echo OPENFSTLDFLAGS = $OPENFSTLDFLAGS >> kaldi.mk
 
   echo "On Linux: Checking for linear algebra header files ..."
-  if [ "$MATHLIB" == "ATLAS" ]; then
-    if [ ! -f $ATLASROOT/include/cblas.h ] || [ ! -f $ATLASROOT/include/clapack.h ] ; then
-      failure "Could not find required header files cblas.h or clapack.h in ATLAS dir '$ATLASROOT/include'"
-    fi
-    echo "Using ATLAS as the linear algebra library."
-
-    # Finding out where the libraries are located:
-    # First we look for the static libraries and then look for dynamic ones.
-    # We're looking for four libraries, all in the same directory, named
-    # libcblas.a, libatlas.a, libf77blas.a, and a library that's variously
-    # named liblapack.a, libclapack.a, or liblapack_atlas.a, but which exports
-    # the symbol ATL_cgetrf.
-    # Note: there is a different type of ATLAS installation that is not
-    # covered.  We saw a case where there was a directory called /usr/lib/atlas
-    # containing {liblapack.a,libblas.a}, and linking against just these two
-    # libraries worked.
-
-    if $static_math; then
-      # Prefer static to dynamic math.
-      linux_configure_static || \
-        linux_configure_debian_ubuntu3 || \
-        linux_configure_dynamic || \
-        linux_configure_debian_ubuntu 64 || \
-        linux_configure_debian_ubuntu || \
-        linux_configure_debian7 || \
-        linux_configure_redhat 64 || \
-        linux_configure_redhat || \
-        linux_configure_redhat_fat 64 || \
-        linux_configure_redhat_fat || \
-        linux_atlas_failure "Failed to configure ATLAS lbiraries";
-    else
-      # Prefer dynamic to static math.
-      linux_configure_debian_ubuntu3 || \
-        linux_configure_dynamic || \
-        linux_configure_static || \
-        linux_configure_debian_ubuntu 64 || \
-        linux_configure_debian_ubuntu || \
-        linux_configure_debian7 || \
-        linux_configure_redhat 64 || \
-        linux_configure_redhat || \
-        linux_configure_redhat_fat 64 || \
-        linux_configure_redhat_fat || \
-        linux_atlas_failure "Failed to configure ATLAS lbiraries";
-    fi
-
-  elif [ "$MATHLIB" == "MKL" ]; then
-    if [ "`uname -m`" != "x86_64" ]; then
-      failure "MKL on Linux only supported for Intel(R) 64 architecture (x86_64).
-      See makefiles/linux_64_mkl.mk to manually configure for other platforms."
-    fi
-
-    if  ( is_set "$MKLROOT" && ! is_set "$MKLLIBDIR" ); then
-      echo -n "Configuring MKL library directory: "
-      MKLLIBDIR=`linux_configure_mkllibdir $MKLROOT`
-      if [ $? -ne 0 ]; then
-        failure "MKL libraries could not be found. Please use the switch --mkl-libdir "
-      else
-        echo "Found: $MKLLIBDIR"
-      fi
-    fi
-
-    MKL_LINK_LINE=`linux_configure_mkl_libraries "$MKLLIBDIR" $static_math $mkl_threading` || exit 1
-    echo "MKL configured with threading: $mkl_threading, libs: $MKL_LINK_LINE"
-
-    MKL_COMPILE_LINE=`linux_configure_mkl_includes "$MKLROOT" "$MKLLIBDIR"` || exit 1
-    echo "MKL include directory configured as: $MKL_COMPILE_LINE"
-    MKL_COMPILE_LINE=" -I${MKL_COMPILE_LINE} "
-
-    THREADING_LINE=`linux_configure_mkl_threading $MKLROOT $MKLLIBDIR $static_math $mkl_threading` || exit 1
-    EXTRA_LIBS=`linux_configure_mkl_extra $static_math $mkl_threading` || exit 1
-    if [ ! -z "$THREADING_LINE" ] || [ ! -z "$EXTRA_LIBS" ]; then
-      echo "MKL threading libraries configured as $THREADING_LINE $EXTRA_LIBS"
-    fi
-
-    echo "Using Intel MKL as the linear algebra library."
-    (
-      cd probe; rm -f mkl-test;
-      g++ mkl-test.cc -o mkl-test $MKL_COMPILE_LINE $MKL_LINK_LINE $THREADING_LINE $EXTRA_LIBS || exit 1
-      test -f ./mkl-test || exit 1
-      ./mkl-test || exit 1
-      cd ..
-    ) || failure "Cannot validate the MKL switches"
-
-    echo MKLROOT = $MKLROOT >> kaldi.mk
-    if [ ! -z $MKLLIBDIR ]; then
-      echo MKLLIB = $MKLLIBDIR >> kaldi.mk
-    fi
-    check_exists makefiles/linux_x86_64_mkl.mk
-    cat makefiles/linux_x86_64_mkl.mk >> kaldi.mk
-    fix_cxx_flag
-    echo "MKLFLAGS = ${MKL_LINK_LINE} ${THREADING_LINE} $EXTRA_LIBS " >> kaldi.mk
-
-    $use_cuda && configure_cuda
-    linux_configure_speex
-    echo "Successfully configured for Linux with MKL libs from $MKLROOT"
-    exit_success;
-
-  elif [ "$MATHLIB" == "CLAPACK" ]; then
-    if [ -z "$CLAPACKROOT" ]; then
-      failure "Must specify the location of CLAPACK with --clapack-root option (and it must exist)"
-    fi
-    if [ ! -f ../tools/CLAPACK/clapack.h ]; then
-      failure could not find file ../tools/CLAPACK/clapack.h
-    fi
-    if [ ! -d "$CLAPACKROOT" ]; then
-      failure "The directory $CLAPACKROOT does not exist"
-    fi
-    # Also check for cblas.h and f2c.h
-    echo "Using CLAPACK as the linear algebra library."
-    if [ ! -f makefiles/linux_clapack.mk ]; then
-      failure "makefiles/linux_clapack.mk not found."
-    fi
-    cat makefiles/linux_clapack.mk >> kaldi.mk
-    fix_cxx_flag
-    echo "Warning (CLAPACK): this part of the configure process is not properly tested and will not work."
-    $use_cuda && configure_cuda
-    linux_configure_speex
-    echo "Successfully configured for Linux with CLAPACK libs from $CLAPACKROOT"
-    exit_success;
-  elif [ "$MATHLIB" == "OPENBLAS" ]; then
+  if [ "$MATHLIB" == "OPENBLAS" ]; then
     OPENBLASROOT=`rel2abs "$OPENBLASROOT"`
     if [ -z "$OPENBLASROOT" ]; then
       failure "Must specify the location of OPENBLAS with --openblas-root option (and it must exist)"
@@ -1053,8 +367,6 @@ if [ "`uname`" == "Linux" ]; then
     echo "OPENBLASROOT = $OPENBLASROOT" >> kaldi.mk
     cat makefiles/linux_openblas.mk >> kaldi.mk
     fix_cxx_flag
-    $use_cuda && configure_cuda
-    linux_configure_speex
     echo "Successfully configured OpenBLAS from $OPENBLASROOT."
     exit_success;
   else
diff --git src/feat/feature-fbank-test.cc src/feat/feature-fbank-test.cc
deleted file mode 100644
index e458df0..0000000
--- src/feat/feature-fbank-test.cc
+++ /dev/null
@@ -1,470 +0,0 @@
-// feat/feature-fbank-test.cc
-
-// Copyright 2009-2011  Karel Vesely;  Petr Motlicek
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "feat/feature-fbank.h"
-#include "base/kaldi-math.h"
-#include "matrix/kaldi-matrix-inl.h"
-#include "feat/wave-reader.h"
-
-using namespace kaldi;
-
-
-
-static void UnitTestReadWave() {
-
-  std::cout << "=== UnitTestReadWave() ===\n";
-
-  Vector<BaseFloat> v, v2;
-
-  std::cout << "<<<=== Reading waveform\n";
-
-  {
-    std::ifstream is("test_data/test.wav", std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    const Matrix<BaseFloat> data(wave.Data());
-    KALDI_ASSERT(data.NumRows() == 1);
-    v.Resize(data.NumCols());
-    v.CopyFromVec(data.Row(0));
-  }
-
-  std::cout << "<<<=== Reading Vector<BaseFloat> waveform, prepared by matlab\n";
-  std::ifstream input(
-    "test_data/test_matlab.ascii"
-  );
-  KALDI_ASSERT(input.good());
-  v2.Read(input, false);
-  input.close();
-
-  std::cout << "<<<=== Comparing freshly read waveform to 'libsndfile' waveform\n";
-  KALDI_ASSERT(v.Dim() == v2.Dim());
-  for (int32 i = 0; i < v.Dim(); i++) {
-    KALDI_ASSERT(v(i) == v2(i));
-  }
-  std::cout << "<<<=== Comparing done\n";
-
-  // std::cout << "== The Waveform Samples == \n";
-  // std::cout << v;
-
-  std::cout << "Test passed :)\n\n";
-
-}
-
-
-
-/**
- */
-static void UnitTestSimple() {
-  std::cout << "=== UnitTestSimple() ===\n";
-
-  Vector<BaseFloat> v(100000);
-  Matrix<BaseFloat> m;
-
-  // init with noise
-  for (int32 i = 0; i < v.Dim(); i++) {
-    v(i) = (abs( i * 433024253 ) % 65535) - (65535 / 2);
-  }
-
-  std::cout << "<<<=== Just make sure it runs... Nothing is compared\n";
-  // the parametrization object
-  FbankOptions op;
-  // trying to have same opts as baseline.
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "rectangular";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = true;
-  op.use_energy = true;
-
-  Fbank fbank(op);
-  // use default parameters
-
-  // compute fbanks.
-  fbank.Compute(v, 1.0, &m, NULL);
-
-  // possibly dump
-  //   std::cout << "== Output features == \n" << m;
-  std::cout << "Test passed :)\n\n";
-}
-
-
-static void UnitTestHTKCompare1() {
-  std::cout << "=== UnitTestHTKCompare1() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fbank_htk.1",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use fbank with default configuration...
-  FbankOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = true;
-  op.mel_opts.htk_mode = true;
-  op.use_energy = false;  // C0 not energy.
-
-  Fbank fbank(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_features;
-  fbank.Compute(waveform, 1.0, &kaldi_features, NULL);
-
-
-  std::cout << "<<<=== Compare with HTK features...\n";
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      /// THE FEATURES ARE ALMOST IDENTICAL WITH HTK!!! (SEE THE TOLERANCE!)
-      if ((std::abs(b - a)) > 0.001) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    000007  // FBANK
-  };
-  {
-    std::ofstream os("tmp.test.wav.fbank_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fbank_kaldi.1");
-}
-
-
-static void UnitTestHTKCompare2() {
-  std::cout << "=== UnitTestHTKCompare2() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fbank_htk.2",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use fbank with default configuration...
-  FbankOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 25.0;
-  op.htk_compat = true;
-  op.mel_opts.htk_mode = true;
-  op.use_energy = false;  // C0 not energy.
-
-  Fbank fbank(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_features;
-  fbank.Compute(waveform, 1.0, &kaldi_features, NULL);
-
-
-  std::cout << "<<<=== Compare with HTK features...\n";
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      /// THE FEATURES ARE ALMOST IDENTICAL WITH HTK!!! (SEE THE TOLERANCE!)
-      if ((std::abs(b - a)) > 0.001) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    000007  // FBANK
-  };
-  {
-    std::ofstream os("tmp.test.wav.fbank_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fbank_kaldi.1");
-}
-
-static void UnitTestHTKCompare3() {
-  std::cout << "=== UnitTestHTKCompare3() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fbank_htk.3",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use fbank with default configuration...
-  FbankOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 25.0;
-  op.htk_compat = true;
-  op.mel_opts.htk_mode = true;
-  op.use_energy = false;  // C0 not energy.
-
-  op.mel_opts.vtln_low = 100.0;
-  op.mel_opts.vtln_high = 7500.0;
-  BaseFloat vtln_warp = 0.9;
-
-  Fbank fbank(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_features;
-  fbank.Compute(waveform, vtln_warp, &kaldi_features, NULL);
-
-
-  std::cout << "<<<=== Compare with HTK features...\n";
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      /// THE FEATURES ARE ALMOST IDENTICAL WITH HTK!!! (SEE THE TOLERANCE!)
-      if ((std::abs(b - a)) > 0.001) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        if (j < 20) passed = false; // We know the last couple of filterbanks differ.  We let this slide.
-        else KALDI_WARN << "Ignoring difference in last fbanks, we know the algorithms differ.";
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    000007  // FBANK
-  };
-  {
-    std::ofstream os("tmp.test.wav.fbank_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fbank_kaldi.1");
-}
-
-
-static void UnitTestHTKCompare4() {
-  std::cout << "=== UnitTestHTKCompare4() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fbank_htk.4",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use fbank with default configuration...
-  FbankOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 25.0;
-  op.htk_compat = true;
-  op.mel_opts.htk_mode = true;
-  op.use_energy = false;  // C0 not energy.
-
-  op.mel_opts.vtln_low = 100.0;
-  op.mel_opts.vtln_high = 7500.0;
-  BaseFloat vtln_warp = 1.1;
-
-  Fbank fbank(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_features;
-  fbank.Compute(waveform, vtln_warp, &kaldi_features, NULL);
-
-
-  std::cout << "<<<=== Compare with HTK features...\n";
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      /// THE FEATURES ARE ALMOST IDENTICAL WITH HTK!!! (SEE THE TOLERANCE!)
-      if ((std::abs(b - a)) > 0.01) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    000007  // FBANK
-  };
-  {
-    std::ofstream os("tmp.test.wav.fbank_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fbank_kaldi.1");
-}
-
-
-
-
-static void UnitTestFeat() {
-  UnitTestReadWave();
-  UnitTestSimple();
-  UnitTestHTKCompare1();
-  UnitTestHTKCompare2();
-  UnitTestHTKCompare3();
-  UnitTestHTKCompare4();
-}
-
-
-
-
-int main() {
-  try {
-    for (int i = 0; i < 5; i++)
-      UnitTestFeat();
-    std::cout << "Tests succeeded.\n";
-    return 0;
-  } catch (const std::exception &e) {
-    std::cerr << e.what();
-    return 1;
-  }
-}
-
-
diff --git src/feat/feature-functions-test.cc src/feat/feature-functions-test.cc
deleted file mode 100644
index e4f6170..0000000
--- src/feat/feature-functions-test.cc
+++ /dev/null
@@ -1,112 +0,0 @@
-// feat/feature-functions-test.cc
-
-// Copyright 2013  Johns Hopkins University (author: Daniel Povey)
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "feat/feature-mfcc.h"
-#include "base/kaldi-math.h"
-#include "matrix/kaldi-matrix-inl.h"
-#include "feat/wave-reader.h"
-
-
-// TODO: some of the other functions should be tested.  
-namespace kaldi {
-
-void UnitTestOnlineCmvn() {
-  for (int32 i = 0; i < 1000; i++) {
-    int32 num_frames = 1 + (Rand() % 10 * 10);
-    int32 dim = 1 + Rand() % 10;
-    SlidingWindowCmnOptions opts;
-    opts.center = (Rand() % 2 == 0);
-    opts.normalize_variance = (Rand() % 2 == 0);
-    opts.cmn_window = 5 + Rand() % 50;
-    opts.min_window = 1 + Rand() % 100;
-    if (opts.min_window > opts.cmn_window)
-      opts.min_window = opts.cmn_window;
-
-    Matrix<BaseFloat> feats(num_frames, dim),
-        output_feats(num_frames, dim),
-        output_feats2(num_frames, dim);
-    feats.SetRandn();
-    SlidingWindowCmn(opts, feats, &output_feats);
-
-    for (int32 t = 0; t < num_frames; t++) {
-      int32 window_begin, window_end;
-      if (opts.center) {
-        window_begin = t - (opts.cmn_window / 2),
-            window_end = window_begin + opts.cmn_window;
-        int32 shift = 0;
-        if (window_begin < 0)
-          shift = -window_begin;
-        else if (window_end > num_frames)
-          shift = num_frames - window_end;
-        window_end += shift;
-        window_begin += shift;
-      } else {
-        window_begin = t - opts.cmn_window;
-        window_end = t + 1;
-        if (window_end < opts.min_window)
-            window_end = opts.min_window;
-      }
-      if (window_begin < 0) window_begin = 0;
-      if (window_end > num_frames) window_end = num_frames;
-      int32 window_size = window_end - window_begin;
-      for (int32 d = 0; d < dim; d++) {
-        double sum = 0.0, sumsq = 0.0;
-        for (int32 t2 = window_begin; t2 < window_end; t2++) {
-          sum += feats(t2, d);
-          sumsq += feats(t2, d) * feats(t2, d);
-        }
-        double mean = sum / window_size, uncentered_covar = sumsq / window_size,
-            covar = uncentered_covar - mean * mean;
-        covar = std::max(covar, 1.0e-20);
-        double data = feats(t, d),
-            norm_data = data - mean;
-        if (opts.normalize_variance) {
-          if (window_size == 1) norm_data = 0.0;
-          else norm_data /= sqrt(covar);
-        }
-        output_feats2(t, d) = norm_data;
-      }
-    }
-    if (! output_feats.ApproxEqual(output_feats2, 0.0001)) {
-      KALDI_ERR << "Features differ " << output_feats << " vs. " << output_feats2;
-    }
-  }
-}
-
-
-}
-
-
-
-int main() {
-  using namespace kaldi;
-  try {
-    UnitTestOnlineCmvn();
-    std::cout << "Tests succeeded.\n";
-    return 0;
-  } catch (const std::exception &e) {
-    std::cerr << e.what();
-    return 1;
-  }
-}
-
-
diff --git src/feat/feature-mfcc-test.cc src/feat/feature-mfcc-test.cc
deleted file mode 100644
index bf23c37..0000000
--- src/feat/feature-mfcc-test.cc
+++ /dev/null
@@ -1,686 +0,0 @@
-// feat/feature-mfcc-test.cc
-
-// Copyright 2009-2011  Karel Vesely;  Petr Motlicek
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "feat/feature-mfcc.h"
-#include "base/kaldi-math.h"
-#include "matrix/kaldi-matrix-inl.h"
-#include "feat/wave-reader.h"
-
-using namespace kaldi;
-
-
-
-static void UnitTestReadWave() {
-
-  std::cout << "=== UnitTestReadWave() ===\n";
-
-  Vector<BaseFloat> v, v2;
-
-  std::cout << "<<<=== Reading waveform\n";
-
-  {
-    std::ifstream is("test_data/test.wav", std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    const Matrix<BaseFloat> data(wave.Data());
-    KALDI_ASSERT(data.NumRows() == 1);
-    v.Resize(data.NumCols());
-    v.CopyFromVec(data.Row(0));
-  }
-
-  std::cout << "<<<=== Reading Vector<BaseFloat> waveform, prepared by matlab\n";
-  std::ifstream input(
-    "test_data/test_matlab.ascii"
-  );
-  KALDI_ASSERT(input.good());
-  v2.Read(input, false);
-  input.close();
-
-  std::cout << "<<<=== Comparing freshly read waveform to 'libsndfile' waveform\n";
-  KALDI_ASSERT(v.Dim() == v2.Dim());
-  for (int32 i = 0; i < v.Dim(); i++) {
-    KALDI_ASSERT(v(i) == v2(i));
-  }
-  std::cout << "<<<=== Comparing done\n";
-
-  // std::cout << "== The Waveform Samples == \n";
-  // std::cout << v;
-
-  std::cout << "Test passed :)\n\n";
-
-}
-
-
-
-/**
- */
-static void UnitTestSimple() {
-  std::cout << "=== UnitTestSimple() ===\n";
-
-  Vector<BaseFloat> v(100000);
-  Matrix<BaseFloat> m;
-
-  // init with noise
-  for (int32 i = 0; i < v.Dim(); i++) {
-    v(i) = (abs( i * 433024253 ) % 65535) - (65535 / 2);
-  }
-
-  std::cout << "<<<=== Just make sure it runs... Nothing is compared\n";
-  // the parametrization object
-  MfccOptions op;
-  // trying to have same opts as baseline.
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "rectangular";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.mel_opts.htk_mode = true;
-  op.htk_compat = true;
-
-  Mfcc mfcc(op);
-  // use default parameters
-
-  // compute mfccs.
-  mfcc.Compute(v, 1.0, &m, NULL);
-
-  // possibly dump
-  //   std::cout << "== Output features == \n" << m;
-  std::cout << "Test passed :)\n\n";
-}
-
-
-static void UnitTestHTKCompare1() {
-  std::cout << "=== UnitTestHTKCompare1() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.1",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.mel_opts.htk_mode = true;
-  op.htk_compat = true;
-  op.use_energy = false;  // C0 not energy.
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.1");
-}
-
-
-static void UnitTestHTKCompare2() {
-  std::cout << "=== UnitTestHTKCompare2() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.2",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.mel_opts.htk_mode = true;
-  op.htk_compat = true;
-  op.use_energy = true;  // Use energy.
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.2",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.2");
-}
-
-
-static void UnitTestHTKCompare3() {
-  std::cout << "=== UnitTestHTKCompare3() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.3",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.htk_compat = true;
-  op.use_energy = true;  // Use energy.
-  op.mel_opts.low_freq = 20.0;
-  //op.mel_opts.debug_mel = true;
-  op.mel_opts.htk_mode = true;
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (static_cast<int32>(i_old) != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.3",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.3");
-}
-
-
-static void UnitTestHTKCompare4() {
-  std::cout << "=== UnitTestHTKCompare4() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.4",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = true;
-  op.use_energy = true;  // Use energy.
-  op.mel_opts.htk_mode = true;
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (static_cast<int32>(i_old) != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.4",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.4");
-}
-
-
-static void UnitTestHTKCompare5() {
-  std::cout << "=== UnitTestHTKCompare5() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.5",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.htk_compat = true;
-  op.use_energy = true;  // Use energy.
-  op.mel_opts.low_freq = 0.0;
-  op.mel_opts.vtln_low = 100.0;
-  op.mel_opts.vtln_high = 7500.0;
-  op.mel_opts.htk_mode = true;
-
-  BaseFloat vtln_warp = 1.1; // our approach identical to htk for warp factor >1,
-  // differs slightly for higher mel bins if warp_factor <0.9
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, vtln_warp, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (static_cast<int32>(i_old) != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.5",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.5");
-}
-
-static void UnitTestHTKCompare6() {
-  std::cout << "=== UnitTestHTKCompare6() ===\n";
-
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.fea_htk.6",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.97;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.num_bins = 24;
-  op.mel_opts.low_freq = 125.0;
-  op.mel_opts.high_freq = 7800.0;
-  op.htk_compat = true;
-  op.use_energy = false;  // C0 not energy.
-
-  Mfcc mfcc(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  mfcc.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 1.0) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (static_cast<int32>(i_old) != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021406  // MFCC_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.fea_kaldi.6",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.fea_kaldi.6");
-}
-
-void UnitTestVtln() {
-  // Test the function VtlnWarpFreq.
-  BaseFloat low_freq = 10, high_freq = 7800,
-      vtln_low_cutoff = 20, vtln_high_cutoff = 7400;
-
-  for (size_t i = 0; i < 100; i++) {
-    BaseFloat freq = 5000, warp_factor = 0.9 + RandUniform() * 0.2;
-    AssertEqual(MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                             low_freq, high_freq, warp_factor,
-                             freq),
-                freq / warp_factor);
-
-    AssertEqual(MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                             low_freq, high_freq, warp_factor,
-                             low_freq),
-                low_freq);
-    AssertEqual(MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                             low_freq, high_freq, warp_factor,
-                             high_freq),
-                high_freq);
-    BaseFloat freq2 = low_freq + (high_freq-low_freq) * RandUniform(),
-        freq3 = freq2 +  (high_freq-freq2) * RandUniform();  // freq3>=freq2
-    BaseFloat w2 = MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                                low_freq, high_freq, warp_factor,
-                                freq2);
-    BaseFloat w3 = MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                                low_freq, high_freq, warp_factor,
-                                freq3);
-    KALDI_ASSERT(w3 >= w2);  // increasing function.
-    BaseFloat w3dash = MelBanks::VtlnWarpFreq(vtln_low_cutoff, vtln_high_cutoff,
-                                    low_freq, high_freq, 1.0,
-                                    freq3);
-    AssertEqual(w3dash, freq3);
-  }
-}
-
-static void UnitTestFeat() {
-  UnitTestVtln();
-  UnitTestReadWave();
-  UnitTestSimple();
-  UnitTestHTKCompare1();
-  UnitTestHTKCompare2();
-  // commenting out this one as it doesn't compare right now I normalized
-  // the way the FFT bins are treated (removed offset of 0.5)... this seems
-  // to relate to the way frequency zero behaves.
-  UnitTestHTKCompare3();
-  UnitTestHTKCompare4();
-  UnitTestHTKCompare5();
-  UnitTestHTKCompare6();
-  std::cout << "Tests succeeded.\n";
-}
-
-
-
-int main() {
-  try {
-    for (int i = 0; i < 5; i++)
-      UnitTestFeat();
-    std::cout << "Tests succeeded.\n";
-    return 0;
-  } catch (const std::exception &e) {
-    std::cerr << e.what();
-    return 1;
-  }
-}
-
-
diff --git src/feat/feature-plp-test.cc src/feat/feature-plp-test.cc
deleted file mode 100644
index a48c939..0000000
--- src/feat/feature-plp-test.cc
+++ /dev/null
@@ -1,177 +0,0 @@
-// feat/feature-plp-test.cc
-
-// Copyright 2009-2011  Karel Vesely;  Petr Motlicek
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "feat/feature-plp.h"
-#include "base/kaldi-math.h"
-#include "matrix/kaldi-matrix-inl.h"
-#include "feat/wave-reader.h"
-
-using namespace kaldi;
-
-
-
-
-
-/**
- */
-static void UnitTestSimple() {
-  std::cout << "=== UnitTestSimple() ===\n";
-
-  Vector<BaseFloat> v(100000);
-  Matrix<BaseFloat> m;
-
-  // init with noise
-  for (int32 i = 0; i < v.Dim(); i++) {
-    v(i) = (abs( i * 433024253 ) % 65535) - (65535 / 2);
-  }
-
-  std::cout << "<<<=== Just make sure it runs... Nothing is compared\n";
-  // the parametrization object
-  PlpOptions op;
-  // trying to have same opts as baseline.
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "rectangular";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-//  op.htk_compat = true;
-
-  Plp plp(op);
-  // use default parameters
-
-  // compute mfccs.
-  plp.Compute(v, 1.0, &m, NULL);
-
-  // possibly dump
-  //   std::cout << "== Output features == \n" << m;
-  std::cout << "Test passed :)\n\n";
-}
-
-
-static void UnitTestHTKCompare1() {
-  std::cout << "=== UnitTestHTKCompare1() ===\n";
-
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // read the HTK features
-  Matrix<BaseFloat> htk_features;
-  {
-    std::ifstream is("test_data/test.wav.plp_htk.1",
-                     std::ios::in | std::ios_base::binary);
-    bool ans = ReadHtk(is, &htk_features, 0);
-    KALDI_ASSERT(ans);
-  }
-
-  // use plp with default configuration...
-  PlpOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = true;
-  op.use_energy = false;  // C0 not energy.
-  op.cepstral_scale = 1.0;
-
-  Plp plp(op);
-
-  // calculate kaldi features
-  Matrix<BaseFloat> kaldi_raw_features;
-  plp.Compute(waveform, 1.0, &kaldi_raw_features, NULL);
-
-  DeltaFeaturesOptions delta_opts;
-  Matrix<BaseFloat> kaldi_features;
-  ComputeDeltas(delta_opts,
-                kaldi_raw_features,
-                &kaldi_features);
-
-  // compare the results
-  bool passed = true;
-  int32 i_old = -1;
-  KALDI_ASSERT(kaldi_features.NumRows() == htk_features.NumRows());
-  KALDI_ASSERT(kaldi_features.NumCols() == htk_features.NumCols());
-  // Ignore ends-- we make slightly different choices than
-  // HTK about how to treat the deltas at the ends.
-  for (int32 i = 10; i+10 < kaldi_features.NumRows(); i++) {
-    for (int32 j = 0; j < kaldi_features.NumCols(); j++) {
-      BaseFloat a = kaldi_features(i, j), b = htk_features(i, j);
-      if ((std::abs(b - a)) > 0.10) {  //<< TOLERANCE TO DIFFERENCES!!!!!
-        // print the non-matching data only once per-line
-        if (i_old != i) {
-          std::cout << "\n\n\n[HTK-row: " << i << "] " << htk_features.Row(i) << "\n";
-          std::cout << "[Kaldi-row: " << i << "] " << kaldi_features.Row(i) << "\n\n\n";
-          i_old = i;
-        }
-        // print indices of non-matching cells
-        std::cout << "[" << i << ", " << j << "]";
-        passed = false;
-  }}}
-  if (!passed) KALDI_ERR << "Test failed";
-
-  // write the htk features for later inspection
-  HtkHeader header = {
-    kaldi_features.NumRows(),
-    100000,  // 10ms
-    static_cast<int16>(sizeof(float)*kaldi_features.NumCols()),
-    021413  // PLP_D_A_0
-  };
-  {
-    std::ofstream os("tmp.test.wav.plp_kaldi.1",
-                     std::ios::out|std::ios::binary);
-    WriteHtk(os, kaldi_features, header);
-  }
-
-  std::cout << "Test passed :)\n\n";
-  
-  unlink("tmp.test.wav.plp_kaldi.1");
-}
-
-
-
-
-static void UnitTestFeat() {
-  UnitTestSimple();
-  UnitTestHTKCompare1();
-}
-
-
-
-
-int main() {
-  try {
-    for (int i = 0; i < 5; i++)
-      UnitTestFeat();
-    std::cout << "Tests succeeded.\n";
-    return 0;
-  } catch (const std::exception &e) {
-    std::cerr << e.what();
-    return 1;
-  }
-}
-
-
diff --git src/feat/feature-sdc-test.cc src/feat/feature-sdc-test.cc
deleted file mode 100644
index 3ecef14..0000000
--- src/feat/feature-sdc-test.cc
+++ /dev/null
@@ -1,170 +0,0 @@
-// feat/feature-sdc-test.cc
-
-// Copyright 2014 David Snyder
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "feat/feature-mfcc.h"
-#include "base/kaldi-math.h"
-#include "matrix/kaldi-matrix-inl.h"
-#include "feat/wave-reader.h"
-
-using namespace kaldi;
-
-static void UnitTestCompareWithDeltaFeatures(Matrix<BaseFloat> &raw_features, int32 window) {
-  std::cout << "=== UnitTestSDCCompareWithDeltaFeatures() ===\n";
-  DeltaFeaturesOptions deltas_opts;
-  deltas_opts.window = window;
-  ShiftedDeltaFeaturesOptions shifted_deltas_opts;
-  shifted_deltas_opts.window = window;
-  Matrix<BaseFloat> deltas_features;
-  Matrix<BaseFloat> shifted_deltas_features;
-  ComputeDeltas(deltas_opts,
-                raw_features,
-                &deltas_features);
-  ComputeShiftedDeltas(shifted_deltas_opts,
-                raw_features,
-                &shifted_deltas_features);
-
-  int32 dd_num_rows = deltas_features.NumRows();
-  int32 sdc_num_rows = shifted_deltas_features.NumRows();
-  int32 num_features = raw_features.NumCols();
- 
-  // Number of rows will be equal, but not
-  // columns, in general.
-  KALDI_ASSERT(dd_num_rows == sdc_num_rows);
-
-  // The raw mfcc features and the first first-order delta features
-  // will be identical in the SDC and Delta-Deltas.
-  for (int32 i = 0; i < dd_num_rows; i++) {
-    for (int32 j = 0; j < 2 * num_features; j++) {
-      BaseFloat a = deltas_features(i, j), b = shifted_deltas_features(i, j);
-      KALDI_ASSERT(std::abs(b - a) < 0.001);
-    }
-  }
-}
-
-static void UnitTestParams(Matrix<BaseFloat> &raw_features, int32 window, 
-                           int32 shift, int32 n_blocks) {
-  std::cout << "=== UnitTestSDCParams() ===\n";
-  ShiftedDeltaFeaturesOptions shifted_deltas_opts;
-  shifted_deltas_opts.window = window;
-  shifted_deltas_opts.num_blocks = n_blocks;
-  shifted_deltas_opts.block_shift = shift;
-
-  Matrix<BaseFloat> shifted_deltas_features;
-  ComputeShiftedDeltas(shifted_deltas_opts,
-                raw_features,
-                &shifted_deltas_features);
-
-  int32 raw_num_cols = raw_features.NumCols();
-  int32 sdc_num_rows = shifted_deltas_features.NumRows();
-  int32 sdc_num_cols = shifted_deltas_features.NumCols();
-
-  KALDI_ASSERT(sdc_num_cols == raw_num_cols * (n_blocks  + 1));
-  
-  /* For every coefficient in the raw feature vector a 
-     delta is calculated and appended to the new feature vector,
-     as is done normally in a delta-deltas computation.
-     In addition, n_blocks delta in advance are also appended.
-     Somewhere in advance of the current position, say at
-     t + l these additional delta are the first order deltas
-     at that position (t + l). The following code works out a
-     mapping from these additional deltas to where they would
-     appear in a delta-deltas computation and verfies these
-     values' equality. */
-  for (int32 i = 0; i < sdc_num_rows; i++) { 
-    for (int32 j = 2 * raw_num_cols; j < sdc_num_cols; j += raw_num_cols) {
-      for (int32 k = 0; k < raw_num_cols; k++) {
-        int32 row = i + (j/raw_num_cols - 1) * shift;
-        if (row < sdc_num_rows) {
-          BaseFloat a = shifted_deltas_features(i, j + k);
-          BaseFloat b = shifted_deltas_features(row, raw_num_cols + k);
-          KALDI_ASSERT(std::abs(a - b) < 0.001);
-        }
-      }
-    }
-  }
-}
-
-static void UnitTestEndEffects(Matrix<BaseFloat> &raw_features, int32 window, 
-                               int32 shift, int32 n_blocks) {
-  std::cout << "=== UnitTestSDCEndEffects() ===\n";
-  ShiftedDeltaFeaturesOptions shifted_deltas_opts;
-  shifted_deltas_opts.window = window;
-  shifted_deltas_opts.num_blocks = n_blocks;
-  shifted_deltas_opts.block_shift = shift;
-
-  Matrix<BaseFloat> shifted_deltas_features;
-  ComputeShiftedDeltas(shifted_deltas_opts,
-                raw_features,
-                &shifted_deltas_features);
-  int32 raw_num_cols = raw_features.NumCols();
-  int32 sdc_num_rows = shifted_deltas_features.NumRows();
-  int32 sdc_num_cols = shifted_deltas_features.NumCols();
-  
-  // If the entire window is out-of-bounds the delta should be zero.
-  for (int32 i = sdc_num_rows - n_blocks + 1; i < sdc_num_rows; i++) {
-    for (int32 j = 2 * raw_num_cols; j < sdc_num_cols; j += raw_num_cols) {
-      for (int32 k = 0; k < raw_num_cols; k++) {
-        if (i + (j/raw_num_cols - 1) * shift - window/2 > sdc_num_rows)
-          KALDI_ASSERT(shifted_deltas_features(i, j + k) <= 0.00001);
-      }
-    } 
-  }
-}
-
-int main() {
-  std::ifstream is("test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // mfcc with default configuration...
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.mel_opts.low_freq = 0.0;
-  op.use_energy = false;
-  Mfcc mfcc(op);
-  Matrix<BaseFloat> raw_features;
-  mfcc.Compute(waveform, 1.0, &raw_features, NULL);
-
-  try {
-    for (int32 window = 1; window < 4; window++) {
-      UnitTestCompareWithDeltaFeatures(raw_features, window);
-      for (int32 shift = 1; shift < 10; shift++) {
-        for (int32 n_blocks = 1; n_blocks < 20; n_blocks += 3) {
-          UnitTestParams(raw_features, window, shift, n_blocks);
-          UnitTestEndEffects(raw_features, window, shift, n_blocks);
-        }
-      }
-    }
-    return 0;
-  } catch (const std::exception &e) {
-    static_cast<void>(e);
-    return 1;
-  }
-  
-}
-
diff --git src/feat/online-feature-test.cc src/feat/online-feature-test.cc
deleted file mode 100644
index 556160f..0000000
--- src/feat/online-feature-test.cc
+++ /dev/null
@@ -1,403 +0,0 @@
-// feat/online-feature-test.cc
-
-// Copyright 2014  IMSL, PKU-HKUST (author: Wei Shi)
-// Copyright 2014  Yanqing Sun, Junjie Wang,
-//                 Daniel Povey, Korbinian Riedhammer
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include "feat/online-feature.h"
-#include "feat/wave-reader.h"
-#include "transform/transform-common.h"
-
-namespace kaldi {
-
-
-template<class Real> static void AssertEqual(const Matrix<Real> &A,
-                                             const Matrix<Real> &B,
-                                             float tol = 0.001) {
-  KALDI_ASSERT(A.NumRows() == B.NumRows()&&A.NumCols() == B.NumCols());
-  for (MatrixIndexT i = 0;i < A.NumRows();i++)
-    for (MatrixIndexT j = 0;j < A.NumCols();j++) {
-      KALDI_ASSERT(std::abs(A(i, j)-B(i, j)) < tol * std::max(1.0,
-        static_cast<double>(std::abs(A(i, j))+std::abs(B(i, j)))));
-    }
-}
-
-void GetOutput(OnlineFeatureInterface *a,
-               Matrix<BaseFloat> *output) {
-  int32 dim = a->Dim();
-  int32 frame_num = 0;
-  OnlineCacheFeature cache(a);
-
-  std::vector<Vector<BaseFloat>* > cached_frames;
-  while (true) {
-    Vector<BaseFloat> garbage(dim);
-    cache.GetFrame(frame_num, &garbage);
-    cached_frames.push_back(new Vector<BaseFloat>(garbage));
-    if (cache.IsLastFrame(frame_num))
-      break;
-    frame_num++;
-  }
-
-  KALDI_ASSERT(cached_frames.size() == a->NumFramesReady());
-
-  output->Resize(cached_frames.size(), dim);
-  for (int32 i = 0; i < cached_frames.size(); i++) {
-    output->CopyRowFromVec(*(cached_frames[i]), i);
-    delete cached_frames[i];
-  }
-  cached_frames.clear();
-  cache.ClearCache();
-}
-
-// Only generate random length for each piece
-bool RandomSplit(int32 wav_dim,
-                 std::vector<int32> *piece_dim,
-                 int32 num_pieces,
-                 int32 trials = 5) {
-  piece_dim->clear();
-  piece_dim->resize(num_pieces, 0);
-
-  int32 dim_mean = wav_dim / (num_pieces * 2);
-  int32 cnt = 0;
-  while (true) {
-    int32 dim_total = 0;
-    for (int32 i = 0; i < num_pieces - 1; i++) {
-      (*piece_dim)[i] = dim_mean + rand() % dim_mean;
-      dim_total += (*piece_dim)[i];
-    }
-    (*piece_dim)[num_pieces - 1] = wav_dim - dim_total;
-
-    if (dim_total > 0 && dim_total < wav_dim)
-      break;
-    if (++cnt > trials)
-      return false;
-  }
-  return true;
-}
-
-// test the OnlineMatrixFeature and OnlineCacheFeature classes.
-void TestOnlineMatrixCacheFeature() {
-  int32 dim = 2 + rand() % 5;  // dimension of features.
-  int32 num_frames = 100 + rand() % 100;
-
-  Matrix<BaseFloat> input_feats(num_frames, dim);
-  input_feats.SetRandn();
-
-  OnlineMatrixFeature matrix_feats(input_feats);
-
-  Matrix<BaseFloat> output_feats;
-  GetOutput(&matrix_feats, &output_feats);
-  AssertEqual(input_feats, output_feats);
-}
-
-void TestOnlineDeltaFeature() {
-  int32 dim = 2 + rand() % 5;  // dimension of features.
-  int32 num_frames = 100 + rand() % 100;
-  DeltaFeaturesOptions opts;
-  opts.order = rand() % 3;
-  opts.window = 1 + rand() % 3;
-
-  int32 output_dim = dim * (1 + opts.order);
-
-  Matrix<BaseFloat> input_feats(num_frames, dim);
-  input_feats.SetRandn();
-
-  OnlineMatrixFeature matrix_feats(input_feats);
-  OnlineDeltaFeature delta_feats(opts, &matrix_feats);
-
-  Matrix<BaseFloat> output_feats1;
-  GetOutput(&delta_feats, &output_feats1);
-
-  Matrix<BaseFloat> output_feats2(num_frames, output_dim);
-  ComputeDeltas(opts, input_feats, &output_feats2);
-
-  KALDI_ASSERT(output_feats1.ApproxEqual(output_feats2));
-}
-
-void TestOnlineSpliceFrames() {
-  int32 dim = 2 + rand() % 5;  // dimension of features.
-  int32 num_frames = 100 + rand() % 100;
-  OnlineSpliceOptions opts;
-  opts.left_context  = 1 + rand() % 4;
-  opts.right_context = 1 + rand() % 4;
-
-  int32 output_dim = dim * (1 + opts.left_context + opts.right_context);
-
-  Matrix<BaseFloat> input_feats(num_frames, dim);
-  input_feats.SetRandn();
-
-  OnlineMatrixFeature matrix_feats(input_feats);
-  OnlineSpliceFrames splice_frame(opts, &matrix_feats);
-
-  Matrix<BaseFloat> output_feats1;
-  GetOutput(&splice_frame, &output_feats1);
-
-  Matrix<BaseFloat> output_feats2(num_frames, output_dim);
-  SpliceFrames(input_feats, opts.left_context, opts.right_context,
-    &output_feats2);
-
-  KALDI_ASSERT(output_feats1.ApproxEqual(output_feats2));
-}
-
-void TestOnlineMfcc() {
-  std::ifstream is("../feat/test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // the parametrization object
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.frame_opts.samp_freq = wave.SampFreq();
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = false;
-  op.use_energy = false;  // C0 not energy.
-  if (RandInt(0, 1) == 0)
-    op.frame_opts.snip_edges = false;
-  Mfcc mfcc(op);
-
-  // compute mfcc offline
-  Matrix<BaseFloat> mfcc_feats;
-  mfcc.Compute(waveform, 1.0, &mfcc_feats, NULL);  // vtln not supported
-
-  // compare
-  // The test waveform is about 1.44s long, so
-  // we try to break it into from 5 pieces to 9(not essential to do so)
-  for (int32 num_piece = 5; num_piece < 10; num_piece++) {
-    OnlineMfcc online_mfcc(op);
-    std::vector<int32> piece_length(num_piece, 0);
-
-    bool ret = RandomSplit(waveform.Dim(), &piece_length, num_piece);
-    KALDI_ASSERT(ret);
-
-    int32 offset_start = 0;
-    for (int32 i = 0; i < num_piece; i++) {
-      Vector<BaseFloat> wave_piece(
-        waveform.Range(offset_start, piece_length[i]));
-      online_mfcc.AcceptWaveform(wave.SampFreq(), wave_piece);
-      offset_start += piece_length[i];
-    }
-    online_mfcc.InputFinished();
-
-    Matrix<BaseFloat> online_mfcc_feats;
-    GetOutput(&online_mfcc, &online_mfcc_feats);
-
-    AssertEqual(mfcc_feats, online_mfcc_feats);
-  }
-}
-
-void TestOnlinePlp() {
-  std::ifstream is("../feat/test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // the parametrization object
-  PlpOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.frame_opts.samp_freq = wave.SampFreq();
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = false;
-  op.use_energy = false;  // C0 not energy.
-  Plp plp(op);
-
-  // compute plp offline
-  Matrix<BaseFloat> plp_feats;
-  plp.Compute(waveform, 1.0, &plp_feats, NULL);  // vtln not supported
-
-  // compare
-  // The test waveform is about 1.44s long, so
-  // we try to break it into from 5 pieces to 9(not essential to do so)
-  for (int32 num_piece = 5; num_piece < 10; num_piece++) {
-    OnlinePlp online_plp(op);
-    std::vector<int32> piece_length(num_piece);
-    bool ret = RandomSplit(waveform.Dim(), &piece_length, num_piece);
-    KALDI_ASSERT(ret);
-
-    int32 offset_start = 0;
-    for (int32 i = 0; i < num_piece; i++) {
-      Vector<BaseFloat> wave_piece(
-        waveform.Range(offset_start, piece_length[i]));
-      online_plp.AcceptWaveform(wave.SampFreq(), wave_piece);
-      offset_start += piece_length[i];
-    }
-    online_plp.InputFinished();
-
-    Matrix<BaseFloat> online_plp_feats;
-    GetOutput(&online_plp, &online_plp_feats);
-
-    AssertEqual(plp_feats, online_plp_feats);
-  }
-}
-
-void TestOnlineTransform() {
-  std::ifstream is("../feat/test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // build online feature interface, take OnlineMfcc as an example
-  MfccOptions op;
-  op.frame_opts.dither = 0.0;
-  op.frame_opts.preemph_coeff = 0.0;
-  op.frame_opts.window_type = "hamming";
-  op.frame_opts.remove_dc_offset = false;
-  op.frame_opts.round_to_power_of_two = true;
-  op.frame_opts.samp_freq = wave.SampFreq();
-  op.mel_opts.low_freq = 0.0;
-  op.htk_compat = false;
-  op.use_energy = false;  // C0 not energy.
-  OnlineMfcc online_mfcc(op);
-
-  online_mfcc.AcceptWaveform(wave.SampFreq(), waveform);
-  online_mfcc.InputFinished();
-  Matrix<BaseFloat> mfcc_feats;
-  GetOutput(&online_mfcc, &mfcc_feats);
-
-  // Affine transform
-  Matrix<BaseFloat> trans(online_mfcc.Dim(), online_mfcc.Dim() + 1);
-  trans.SetRandn();
-  OnlineTransform online_trans(trans, &online_mfcc);
-
-  Matrix<BaseFloat> trans_feats;
-  GetOutput(&online_trans, &trans_feats);
-
-  Matrix<BaseFloat> output_feats(mfcc_feats.NumRows(), mfcc_feats.NumCols());
-  for (int32 i = 0; i < mfcc_feats.NumRows(); i++) {
-    Vector<BaseFloat> vec_tmp(mfcc_feats.Row(i));
-    ApplyAffineTransform(trans, &vec_tmp);
-    output_feats.CopyRowFromVec(vec_tmp, i);
-  }
-
-  AssertEqual(trans_feats, output_feats);
-}
-
-void TestOnlineAppendFeature() {
-  std::ifstream is("../feat/test_data/test.wav", std::ios_base::binary);
-  WaveData wave;
-  wave.Read(is);
-  KALDI_ASSERT(wave.Data().NumRows() == 1);
-  SubVector<BaseFloat> waveform(wave.Data(), 0);
-
-  // the parametrization object for 1st stream mfcc feature
-  MfccOptions mfcc_op;
-  mfcc_op.frame_opts.dither = 0.0;
-  mfcc_op.frame_opts.preemph_coeff = 0.0;
-  mfcc_op.frame_opts.window_type = "hamming";
-  mfcc_op.frame_opts.remove_dc_offset = false;
-  mfcc_op.frame_opts.round_to_power_of_two = true;
-  mfcc_op.frame_opts.samp_freq = wave.SampFreq();
-  mfcc_op.mel_opts.low_freq = 0.0;
-  mfcc_op.htk_compat = false;
-  mfcc_op.use_energy = false;  // C0 not energy.
-  Mfcc mfcc(mfcc_op);
-
-  // compute mfcc offline
-  Matrix<BaseFloat> mfcc_feats;
-  mfcc.Compute(waveform, 1.0, &mfcc_feats, NULL);  // vtln not supported
-
-  // the parametrization object for 2nd stream plp feature
-  PlpOptions plp_op;
-  plp_op.frame_opts.dither = 0.0;
-  plp_op.frame_opts.preemph_coeff = 0.0;
-  plp_op.frame_opts.window_type = "hamming";
-  plp_op.frame_opts.remove_dc_offset = false;
-  plp_op.frame_opts.round_to_power_of_two = true;
-  plp_op.frame_opts.samp_freq = wave.SampFreq();
-  plp_op.mel_opts.low_freq = 0.0;
-  plp_op.htk_compat = false;
-  plp_op.use_energy = false;  // C0 not energy.
-  Plp plp(plp_op);
-
-  // compute plp offline
-  Matrix<BaseFloat> plp_feats;
-  plp.Compute(waveform, 1.0, &plp_feats, NULL);  // vtln not supported
-
-  // compare
-  // The test waveform is about 1.44s long, so
-  // we try to break it into from 5 pieces to 9(not essential to do so)
-  for (int32 num_piece = 5; num_piece < 10; num_piece++) {
-    OnlineMfcc online_mfcc(mfcc_op);
-    OnlinePlp online_plp(plp_op);
-    OnlineAppendFeature online_mfcc_plp(&online_mfcc, &online_plp);
-
-    std::vector<int32> piece_length(num_piece);
-    bool ret = RandomSplit(waveform.Dim(), &piece_length, num_piece);
-    KALDI_ASSERT(ret);
-    int32 offset_start = 0;
-    for (int32 i = 0; i < num_piece; i++) {
-      Vector<BaseFloat> wave_piece(
-        waveform.Range(offset_start, piece_length[i]));
-      online_mfcc.AcceptWaveform(wave.SampFreq(), wave_piece);
-      online_plp.AcceptWaveform(wave.SampFreq(), wave_piece);
-      offset_start += piece_length[i];
-    }
-    online_mfcc.InputFinished();
-    online_plp.InputFinished();
-
-    Matrix<BaseFloat> online_mfcc_plp_feats;
-    GetOutput(&online_mfcc_plp, &online_mfcc_plp_feats);
-
-    // compare mfcc_feats & plp_features with online_mfcc_plp_feats
-    KALDI_ASSERT(mfcc_feats.NumRows() == online_mfcc_plp_feats.NumRows()
-      && plp_feats.NumRows() == online_mfcc_plp_feats.NumRows()
-      && mfcc_feats.NumCols() + plp_feats.NumCols()
-         == online_mfcc_plp_feats.NumCols());
-    for (MatrixIndexT i = 0; i < online_mfcc_plp_feats.NumRows(); i++) {
-      for (MatrixIndexT j = 0; j < mfcc_feats.NumCols(); j++) {
-        KALDI_ASSERT(std::abs(mfcc_feats(i, j) - online_mfcc_plp_feats(i, j))
-          < 0.0001*std::max(1.0, static_cast<double>(std::abs(mfcc_feats(i, j))
-                                    + std::abs(online_mfcc_plp_feats(i, j)))));
-      }
-      for (MatrixIndexT k = 0; k < plp_feats.NumCols(); k++) {
-        KALDI_ASSERT(
-          std::abs(plp_feats(i, k) -
-            online_mfcc_plp_feats(i, mfcc_feats.NumCols() + k))
-          < 0.0001*std::max(1.0, static_cast<double>(std::abs(plp_feats(i, k))
-            +std::abs(online_mfcc_plp_feats(i, mfcc_feats.NumCols() + k)))));
-      }
-    }
-  }
-}
-
-}  // end namespace kaldi
-
-int main() {
-  using namespace kaldi;
-  for (int i = 0; i < 10; i++) {
-    TestOnlineMatrixCacheFeature();
-    TestOnlineDeltaFeature();
-    TestOnlineSpliceFrames();
-    TestOnlineMfcc();
-    TestOnlinePlp();
-    TestOnlineTransform();
-    TestOnlineAppendFeature();
-  }
-  std::cout << "Test OK.\n";
-}
diff --git src/feat/online-feature.cc src/feat/online-feature.cc
deleted file mode 100644
index 267a472..0000000
--- src/feat/online-feature.cc
+++ /dev/null
@@ -1,514 +0,0 @@
-// feat/online-feature.cc
-
-// Copyright    2013  Johns Hopkins University (author: Daniel Povey)
-//              2014  Yanqing Sun, Junjie Wang,
-//                    Daniel Povey, Korbinian Riedhammer
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include "feat/online-feature.h"
-#include "transform/cmvn.h"
-
-namespace kaldi {
-
-template<class C>
-void OnlineGenericBaseFeature<C>::GetFrame(int32 frame,
-                                           VectorBase<BaseFloat> *feat) {
-  // 'at' does size checking.
-  feat->CopyFromVec(*(features_.at(frame)));
-};
-
-template<class C>
-OnlineGenericBaseFeature<C>::OnlineGenericBaseFeature(
-    const typename C::Options &opts):
-    computer_(opts), window_function_(computer_.GetFrameOptions()),
-    input_finished_(false), waveform_offset_(0) { }
-
-template<class C>
-void OnlineGenericBaseFeature<C>::AcceptWaveform(BaseFloat sampling_rate,
-                                                 const VectorBase<BaseFloat> &waveform) {
-  BaseFloat expected_sampling_rate = computer_.GetFrameOptions().samp_freq;
-  if (sampling_rate != expected_sampling_rate)
-    KALDI_ERR << "Sampling frequency mismatch, expected "
-              << expected_sampling_rate << ", got " << sampling_rate;
-  if (waveform.Dim() == 0)
-    return;  // Nothing to do.
-  if (input_finished_)
-    KALDI_ERR << "AcceptWaveform called after InputFinished() was called.";
-  // append 'waveform' to 'waveform_remainder_.'
-  Vector<BaseFloat> appended_wave(waveform_remainder_.Dim() + waveform.Dim());
-  if (waveform_remainder_.Dim() != 0)
-    appended_wave.Range(0, waveform_remainder_.Dim()).CopyFromVec(
-        waveform_remainder_);
-  appended_wave.Range(waveform_remainder_.Dim(), waveform.Dim()).CopyFromVec(
-      waveform);
-  waveform_remainder_.Swap(&appended_wave);
-  ComputeFeatures();
-}
-
-template<class C>
-void OnlineGenericBaseFeature<C>::ComputeFeatures() {
-  const FrameExtractionOptions &frame_opts = computer_.GetFrameOptions();
-  int64 num_samples_total = waveform_offset_ + waveform_remainder_.Dim();
-  int32 num_frames_old = features_.size(),
-      num_frames_new = NumFrames(num_samples_total, frame_opts,
-                                 input_finished_);
-  KALDI_ASSERT(num_frames_new >= num_frames_old);
-  features_.resize(num_frames_new, NULL);
-
-  Vector<BaseFloat> window;
-  bool need_raw_log_energy = computer_.NeedRawLogEnergy();
-  for (int32 frame = num_frames_old; frame < num_frames_new; frame++) {
-    BaseFloat raw_log_energy = 0.0;
-    ExtractWindow(waveform_offset_, waveform_remainder_, frame,
-                  frame_opts, window_function_, &window,
-                  need_raw_log_energy ? &raw_log_energy : NULL);
-    Vector<BaseFloat> *this_feature = new Vector<BaseFloat>(computer_.Dim(),
-                                                            kUndefined);
-    // note: this online feature-extraction code does not support VTLN.
-    BaseFloat vtln_warp = 1.0;
-    computer_.Compute(raw_log_energy, vtln_warp, &window, this_feature);
-    features_[frame] = this_feature;
-  }
-  // OK, we will now discard any portion of the signal that will not be
-  // necessary to compute frames in the future.
-  int64 first_sample_of_next_frame = FirstSampleOfFrame(num_frames_new,
-                                                        frame_opts);
-  int32 samples_to_discard = first_sample_of_next_frame - waveform_offset_;
-  if (samples_to_discard > 0) {
-    // discard the leftmost part of the waveform that we no longer need.
-    int32 new_num_samples = waveform_remainder_.Dim() - samples_to_discard;
-    if (new_num_samples <= 0) {
-      // odd, but we'll try to handle it.
-      waveform_offset_ += waveform_remainder_.Dim();
-      waveform_remainder_.Resize(0);
-    } else {
-      Vector<BaseFloat> new_remainder(new_num_samples);
-      new_remainder.CopyFromVec(waveform_remainder_.Range(samples_to_discard,
-                                                          new_num_samples));
-      waveform_offset_ += samples_to_discard;
-      waveform_remainder_.Swap(&new_remainder);
-    }
-  }
-}
-
-// instantiate the templates defined here for MFCC, PLP and filterbank classes.
-template class OnlineGenericBaseFeature<MfccComputer>;
-template class OnlineGenericBaseFeature<PlpComputer>;
-template class OnlineGenericBaseFeature<FbankComputer>;
-
-
-OnlineCmvnState::OnlineCmvnState(const OnlineCmvnState &other):
-    speaker_cmvn_stats(other.speaker_cmvn_stats),
-    global_cmvn_stats(other.global_cmvn_stats),
-    frozen_state(other.frozen_state) { }
-
-void OnlineCmvnState::Write(std::ostream &os, bool binary) const {
-  WriteToken(os, binary, "<OnlineCmvnState>");  // magic string.
-  WriteToken(os, binary, "<SpeakerCmvnStats>");
-  speaker_cmvn_stats.Write(os, binary);
-  WriteToken(os, binary, "<GlobalCmvnStats>");
-  global_cmvn_stats.Write(os, binary);
-  WriteToken(os, binary, "<FrozenState>");
-  frozen_state.Write(os, binary);
-  WriteToken(os, binary, "</OnlineCmvnState>");
-}
-
-void OnlineCmvnState::Read(std::istream &is, bool binary) {
-  ExpectToken(is, binary, "<OnlineCmvnState>");  // magic string.
-  ExpectToken(is, binary, "<SpeakerCmvnStats>");
-  speaker_cmvn_stats.Read(is, binary);
-  ExpectToken(is, binary, "<GlobalCmvnStats>");
-  global_cmvn_stats.Read(is, binary);
-  ExpectToken(is, binary, "<FrozenState>");
-  frozen_state.Read(is, binary);
-  ExpectToken(is, binary, "</OnlineCmvnState>");
-}
-
-
-
-OnlineCmvn::OnlineCmvn(const OnlineCmvnOptions &opts,
-                       const OnlineCmvnState &cmvn_state,
-                       OnlineFeatureInterface *src):
-    opts_(opts), src_(src) {
-  SetState(cmvn_state);
-  if (!SplitStringToIntegers(opts.skip_dims, ":", false, &skip_dims_))
-    KALDI_ERR << "Bad --skip-dims option (should be colon-separated list of "
-              <<  "integers)";
-}
-
-OnlineCmvn::OnlineCmvn(const OnlineCmvnOptions &opts,
-                       OnlineFeatureInterface *src): opts_(opts), src_(src) {
-  if (!SplitStringToIntegers(opts.skip_dims, ":", false, &skip_dims_))
-    KALDI_ERR << "Bad --skip-dims option (should be colon-separated list of "
-              <<  "integers)";
-}
-
-
-void OnlineCmvn::GetMostRecentCachedFrame(int32 frame,
-                                          int32 *cached_frame,
-                                          Matrix<double> *stats) {
-  KALDI_ASSERT(frame >= 0);
-  InitRingBufferIfNeeded();
-  // look for a cached frame on a previous frame as close as possible in time
-  // to "frame".  Return if we get one.
-  for (int32 t = frame; t >= 0 && t >= frame - opts_.ring_buffer_size; t--) {
-    if (t % opts_.modulus == 0) {
-      // if this frame should be cached in cached_stats_modulo_, then
-      // we'll look there, and we won't go back any further in time.
-      break;
-    }
-    int32 index = t % opts_.ring_buffer_size;
-    if (cached_stats_ring_[index].first == t) {
-      *cached_frame = t;
-      *stats = cached_stats_ring_[index].second;
-      return;
-    }
-  }
-  int32 n = frame / opts_.modulus;
-  if (n >= cached_stats_modulo_.size()) {
-    if (cached_stats_modulo_.size() == 0) {
-      *cached_frame = -1;
-      stats->Resize(2, this->Dim() + 1);
-      return;
-    } else {
-      n = static_cast<int32>(cached_stats_modulo_.size() - 1);
-    }
-  }
-  *cached_frame = n * opts_.modulus;
-  KALDI_ASSERT(cached_stats_modulo_[n] != NULL);
-  *stats = *(cached_stats_modulo_[n]);
-}
-
-// Initialize ring buffer for caching stats.
-void OnlineCmvn::InitRingBufferIfNeeded() {
-  if (cached_stats_ring_.empty() && opts_.ring_buffer_size > 0) {
-    Matrix<double> temp(2, this->Dim() + 1);
-    cached_stats_ring_.resize(opts_.ring_buffer_size,
-                              std::pair<int32, Matrix<double> >(-1, temp));
-  }
-}
-
-void OnlineCmvn::CacheFrame(int32 frame, const Matrix<double> &stats) {
-  KALDI_ASSERT(frame >= 0);
-  if (frame % opts_.modulus == 0) {  // store in cached_stats_modulo_.
-    int32 n = frame / opts_.modulus;
-    if (n >= cached_stats_modulo_.size()) {
-      // The following assert is a limitation on in what order you can call
-      // CacheFrame.  Fortunately the calling code always calls it in sequence,
-      // which it has to because you need a previous frame to compute the
-      // current one.
-      KALDI_ASSERT(n == cached_stats_modulo_.size());
-      cached_stats_modulo_.push_back(new Matrix<double>(stats));
-    } else {
-      KALDI_WARN << "Did not expect to reach this part of code.";
-      // do what seems right, but we shouldn't get here.
-      cached_stats_modulo_[n]->CopyFromMat(stats);
-    }
-  } else {  // store in the ring buffer.
-    InitRingBufferIfNeeded();
-    if (!cached_stats_ring_.empty()) {
-      int32 index = frame % cached_stats_ring_.size();
-      cached_stats_ring_[index].first = frame;
-      cached_stats_ring_[index].second.CopyFromMat(stats);
-    }
-  }
-}
-
-OnlineCmvn::~OnlineCmvn() {
-  for (size_t i = 0; i < cached_stats_modulo_.size(); i++)
-    delete cached_stats_modulo_[i];
-  cached_stats_modulo_.clear();
-}
-
-void OnlineCmvn::ComputeStatsForFrame(int32 frame,
-                                      MatrixBase<double> *stats_out) {
-  KALDI_ASSERT(frame >= 0 && frame < src_->NumFramesReady());
-
-  int32 dim = this->Dim(), cur_frame;
-  Matrix<double> stats(2, dim + 1);
-  GetMostRecentCachedFrame(frame, &cur_frame, &stats);
-
-  Vector<BaseFloat> feats(dim);
-  Vector<double> feats_dbl(dim);
-  while (cur_frame < frame) {
-    cur_frame++;
-    src_->GetFrame(cur_frame, &feats);
-    feats_dbl.CopyFromVec(feats);
-    stats.Row(0).Range(0, dim).AddVec(1.0, feats_dbl);
-    stats.Row(1).Range(0, dim).AddVec2(1.0, feats_dbl);
-    stats(0, dim) += 1.0;
-    // it's a sliding buffer; a frame at the back may be
-    // leaving the buffer so we have to subtract that.
-    int32 prev_frame = cur_frame - opts_.cmn_window;
-    if (prev_frame >= 0) {
-      // we need to subtract frame prev_f from the stats.
-      src_->GetFrame(prev_frame, &feats);
-      feats_dbl.CopyFromVec(feats);
-      stats.Row(0).Range(0, dim).AddVec(-1.0, feats_dbl);
-      stats.Row(1).Range(0, dim).AddVec2(-1.0, feats_dbl);
-      stats(0, dim) -= 1.0;
-    }
-    CacheFrame(cur_frame, stats);
-  }
-  stats_out->CopyFromMat(stats);
-}
-
-
-// static
-void OnlineCmvn::SmoothOnlineCmvnStats(const MatrixBase<double> &speaker_stats,
-                                       const MatrixBase<double> &global_stats,
-                                       const OnlineCmvnOptions &opts,
-                                       MatrixBase<double> *stats) {
-  int32 dim = stats->NumCols() - 1;
-  double cur_count = (*stats)(0, dim);
-  // If count exceeded cmn_window it would be an error in how "window_stats"
-  // was accumulated.
-  KALDI_ASSERT(cur_count <= 1.001 * opts.cmn_window);
-  if (cur_count >= opts.cmn_window) return;
-  if (speaker_stats.NumRows() != 0) {  // if we have speaker stats..
-    double count_from_speaker = opts.cmn_window - cur_count,
-        speaker_count = speaker_stats(0, dim);
-    if (count_from_speaker > opts.speaker_frames)
-      count_from_speaker = opts.speaker_frames;
-    if (count_from_speaker > speaker_count)
-      count_from_speaker = speaker_count;
-    if (count_from_speaker > 0.0)
-      stats->AddMat(count_from_speaker / speaker_count,
-                             speaker_stats);
-    cur_count = (*stats)(0, dim);
-  }
-  if (cur_count >= opts.cmn_window) return;
-  if (global_stats.NumRows() != 0) {
-    double count_from_global = opts.cmn_window - cur_count,
-        global_count = global_stats(0, dim);
-    KALDI_ASSERT(global_count > 0.0);
-    if (count_from_global > opts.global_frames)
-      count_from_global = opts.global_frames;
-    if (count_from_global > 0.0)
-      stats->AddMat(count_from_global / global_count,
-                    global_stats);
-  } else {
-    KALDI_ERR << "Global CMN stats are required";
-  }
-}
-
-void OnlineCmvn::GetFrame(int32 frame,
-                          VectorBase<BaseFloat> *feat) {
-  src_->GetFrame(frame, feat);
-  KALDI_ASSERT(feat->Dim() == this->Dim());
-  int32 dim = feat->Dim();
-  Matrix<double> stats(2, dim + 1);
-  if (frozen_state_.NumRows() != 0) {  // the CMVN state has been frozen.
-    stats.CopyFromMat(frozen_state_);
-  } else {
-    // first get the raw CMVN stats (this involves caching..)
-    this->ComputeStatsForFrame(frame, &stats);
-    // now smooth them.
-    SmoothOnlineCmvnStats(orig_state_.speaker_cmvn_stats,
-                          orig_state_.global_cmvn_stats,
-                          opts_,
-                          &stats);
-  }
-
-  if (!skip_dims_.empty())
-    FakeStatsForSomeDims(skip_dims_, &stats);
-
-  // call the function ApplyCmvn declared in ../transform/cmvn.h, which
-  // requires a matrix.
-  Matrix<BaseFloat> feat_mat(1, dim);
-  feat_mat.Row(0).CopyFromVec(*feat);
-  // the function ApplyCmvn takes a matrix, so form a one-row matrix to give it.
-  if (opts_.normalize_mean)
-    ApplyCmvn(stats, opts_.normalize_variance, &feat_mat);
-  else
-    KALDI_ASSERT(!opts_.normalize_variance);
-  feat->CopyFromVec(feat_mat.Row(0));
-}
-
-void OnlineCmvn::Freeze(int32 cur_frame) {
-  int32 dim = this->Dim();
-  Matrix<double> stats(2, dim + 1);
-  // get the raw CMVN stats
-  this->ComputeStatsForFrame(cur_frame, &stats);
-  // now smooth them.
-  SmoothOnlineCmvnStats(orig_state_.speaker_cmvn_stats,
-                        orig_state_.global_cmvn_stats,
-                        opts_,
-                        &stats);
-  this->frozen_state_ = stats;
-}
-
-void OnlineCmvn::GetState(int32 cur_frame,
-                          OnlineCmvnState *state_out) {
-  *state_out = this->orig_state_;
-  { // This block updates state_out->speaker_cmvn_stats
-    int32 dim = this->Dim();
-    if (state_out->speaker_cmvn_stats.NumRows() == 0)
-      state_out->speaker_cmvn_stats.Resize(2, dim + 1);
-    Vector<BaseFloat> feat(dim);
-    Vector<double> feat_dbl(dim);
-    for (int32 t = 0; t <= cur_frame; t++) {
-      src_->GetFrame(t, &feat);
-      feat_dbl.CopyFromVec(feat);
-      state_out->speaker_cmvn_stats(0, dim) += 1.0;
-      state_out->speaker_cmvn_stats.Row(0).Range(0, dim).AddVec(1.0, feat_dbl);
-      state_out->speaker_cmvn_stats.Row(1).Range(0, dim).AddVec2(1.0, feat_dbl);
-    }
-  }
-  // Store any frozen state (the effect of the user possibly
-  // having called Freeze().
-  state_out->frozen_state = frozen_state_;
-}
-
-void OnlineCmvn::SetState(const OnlineCmvnState &cmvn_state) {
-  KALDI_ASSERT(cached_stats_modulo_.empty() &&
-               "You cannot call SetState() after processing data.");
-  orig_state_ = cmvn_state;
-  frozen_state_ = cmvn_state.frozen_state;
-}
-
-int32 OnlineSpliceFrames::NumFramesReady() const {
-  int32 num_frames = src_->NumFramesReady();
-  if (num_frames > 0 && src_->IsLastFrame(num_frames-1))
-    return num_frames;
-  else
-    return std::max<int32>(0, num_frames - right_context_);
-}
-
-void OnlineSpliceFrames::GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-  KALDI_ASSERT(left_context_ >= 0 && right_context_ >= 0);
-  KALDI_ASSERT(frame >= 0 && frame < NumFramesReady());
-  int32 dim_in = src_->Dim();
-  KALDI_ASSERT(feat->Dim() == dim_in * (1 + left_context_ + right_context_));
-  int32 T = src_->NumFramesReady();
-  for (int32 t2 = frame - left_context_; t2 <= frame + right_context_; t2++) {
-    int32 t2_limited = t2;
-    if (t2_limited < 0) t2_limited = 0;
-    if (t2_limited >= T) t2_limited = T - 1;
-    int32 n = t2 - (frame - left_context_);  // 0 for left-most frame,
-                                             // increases to the right.
-    SubVector<BaseFloat> part(*feat, n * dim_in, dim_in);
-    src_->GetFrame(t2_limited, &part);
-  }
-}
-
-OnlineTransform::OnlineTransform(const MatrixBase<BaseFloat> &transform,
-                                 OnlineFeatureInterface *src):
-    src_(src) {
-  int32 src_dim = src_->Dim();
-  if (transform.NumCols() == src_dim) {  // Linear transform
-    linear_term_ = transform;
-    offset_.Resize(transform.NumRows());  // Resize() will zero it.
-  } else if (transform.NumCols() == src_dim + 1) {  // Affine transform
-    linear_term_ = transform.Range(0, transform.NumRows(), 0, src_dim);
-    offset_.Resize(transform.NumRows());
-    offset_.CopyColFromMat(transform, src_dim);
-  } else {
-    KALDI_ERR << "Dimension mismatch: source features have dimension "
-              << src_dim << " and LDA #cols is " << transform.NumCols();
-  }
-}
-
-void OnlineTransform::GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-  Vector<BaseFloat> input_feat(linear_term_.NumCols());
-  src_->GetFrame(frame, &input_feat);
-  feat->CopyFromVec(offset_);
-  feat->AddMatVec(1.0, linear_term_, kNoTrans, input_feat, 1.0);
-}
-
-
-int32 OnlineDeltaFeature::Dim() const {
-  int32 src_dim = src_->Dim();
-  return src_dim * (1 + opts_.order);
-}
-
-int32 OnlineDeltaFeature::NumFramesReady() const {
-  int32 num_frames = src_->NumFramesReady(),
-      context = opts_.order * opts_.window;
-  // "context" is the number of frames on the left or (more relevant
-  // here) right which we need in order to produce the output.
-  if (num_frames > 0 && src_->IsLastFrame(num_frames-1))
-    return num_frames;
-  else
-    return std::max<int32>(0, num_frames - context);
-}
-
-void OnlineDeltaFeature::GetFrame(int32 frame,
-                                      VectorBase<BaseFloat> *feat) {
-  KALDI_ASSERT(frame >= 0 && frame < NumFramesReady());
-  KALDI_ASSERT(feat->Dim() == Dim());
-  // We'll produce a temporary matrix containing the features we want to
-  // compute deltas on, but truncated to the necessary context.
-  int32 context = opts_.order * opts_.window;
-  int32 left_frame = frame - context,
-      right_frame = frame + context,
-      src_frames_ready = src_->NumFramesReady();
-  if (left_frame < 0) left_frame = 0;
-  if (right_frame >= src_frames_ready)
-    right_frame = src_frames_ready - 1;
-  KALDI_ASSERT(right_frame >= left_frame);
-  int32 temp_num_frames = right_frame + 1 - left_frame,
-      src_dim = src_->Dim();
-  Matrix<BaseFloat> temp_src(temp_num_frames, src_dim);
-  for (int32 t = left_frame; t <= right_frame; t++) {
-    SubVector<BaseFloat> temp_row(temp_src, t - left_frame);
-    src_->GetFrame(t, &temp_row);
-  }
-  int32 temp_t = frame - left_frame;  // temp_t is the offset of frame "frame"
-                                      // within temp_src
-  delta_features_.Process(temp_src, temp_t, feat);
-}
-
-
-OnlineDeltaFeature::OnlineDeltaFeature(const DeltaFeaturesOptions &opts,
-                                       OnlineFeatureInterface *src):
-    src_(src), opts_(opts), delta_features_(opts) { }
-
-void OnlineCacheFeature::GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-  KALDI_ASSERT(frame >= 0);
-  if (static_cast<size_t>(frame) < cache_.size() && cache_[frame] != NULL) {
-    feat->CopyFromVec(*(cache_[frame]));
-  } else {
-    if (static_cast<size_t>(frame) >= cache_.size())
-      cache_.resize(frame + 1, NULL);
-    int32 dim = this->Dim();
-    cache_[frame] = new Vector<BaseFloat>(dim);
-    // The following call will crash if frame "frame" is not ready.
-    src_->GetFrame(frame, cache_[frame]);
-    feat->CopyFromVec(*(cache_[frame]));
-  }
-}
-
-void OnlineCacheFeature::ClearCache() {
-  for (size_t i = 0; i < cache_.size(); i++)
-    delete cache_[i];
-  cache_.resize(0);
-}
-
-
-
-void OnlineAppendFeature::GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-  KALDI_ASSERT(feat->Dim() == Dim());
-
-  SubVector<BaseFloat> feat1(*feat, 0, src1_->Dim());
-  SubVector<BaseFloat> feat2(*feat, src1_->Dim(), src2_->Dim());
-  src1_->GetFrame(frame, &feat1);
-  src2_->GetFrame(frame, &feat2);
-};
-
-
-}  // namespace kaldi
diff --git src/feat/online-feature.h src/feat/online-feature.h
deleted file mode 100644
index ba87f69..0000000
--- src/feat/online-feature.h
+++ /dev/null
@@ -1,590 +0,0 @@
-// feat/online-feature.h
-
-// Copyright 2013   Johns Hopkins University (author: Daniel Povey)
-//           2014   Yanqing Sun, Junjie Wang,
-//                  Daniel Povey, Korbinian Riedhammer
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#ifndef KALDI_FEAT_ONLINE_FEATURE_H_
-#define KALDI_FEAT_ONLINE_FEATURE_H_
-
-#include <string>
-#include <vector>
-#include <deque>
-
-#include "matrix/matrix-lib.h"
-#include "util/common-utils.h"
-#include "base/kaldi-error.h"
-#include "feat/feature-functions.h"
-#include "feat/feature-mfcc.h"
-#include "feat/feature-plp.h"
-#include "feat/feature-fbank.h"
-#include "itf/online-feature-itf.h"
-
-namespace kaldi {
-/// @addtogroup  onlinefeat OnlineFeatureExtraction
-/// @{
-
-
-/// This is a templated class for online feature extraction;
-/// it's templated on a class like MfccComputer or PlpComputer
-/// that does the basic feature extraction.
-template<class C>
-class OnlineGenericBaseFeature: public OnlineBaseFeature {
- public:
-  //
-  // First, functions that are present in the interface:
-  //
-  virtual int32 Dim() const { return computer_.Dim(); }
-
-  // Note: IsLastFrame() will only ever return true if you have called
-  // InputFinished() (and this frame is the last frame).
-  virtual bool IsLastFrame(int32 frame) const {
-    return input_finished_ && frame == NumFramesReady() - 1;
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return computer_.GetFrameOptions().frame_shift_ms * 1.0e-03;
-  }
-
-  virtual int32 NumFramesReady() const { return features_.size(); }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  // Next, functions that are not in the interface.
-
-
-  // Constructor from options class
-  explicit OnlineGenericBaseFeature(const typename C::Options &opts);
-
-  // This would be called from the application, when you get
-  // more wave data.  Note: the sampling_rate is only provided so
-  // the code can assert that it matches the sampling rate
-  // expected in the options.
-  virtual void AcceptWaveform(BaseFloat sampling_rate,
-                              const VectorBase<BaseFloat> &waveform);
-
-
-  // InputFinished() tells the class you won't be providing any
-  // more waveform.  This will help flush out the last frame or two
-  // of features, in the case where snip-edges == false; it also
-  // affects the return value of IsLastFrame().
-  virtual void InputFinished() {
-    input_finished_ = true;
-    ComputeFeatures();
-  }
-
-  ~OnlineGenericBaseFeature() {
-    DeletePointers(&features_);
-  }
-
- private:
-  // This function computes any additional feature frames that it is possible to
-  // compute from 'waveform_remainder_', which at this point may contain more
-  // than just a remainder-sized quantity (because AcceptWaveform() appends to
-  // waveform_remainder_ before calling this function).  It adds these feature
-  // frames to features_, and shifts off any now-unneeded samples of input from
-  // waveform_remainder_ while incrementing waveform_offset_ by the same amount.
-  void ComputeFeatures();
-
-  C computer_;  // class that does the MFCC or PLP or filterbank computation
-
-  FeatureWindowFunction window_function_;
-
-  // features_ is the Mfcc or Plp or Fbank features that we have already computed.
-
-  std::vector<Vector<BaseFloat>*> features_;
-
-  // True if the user has called "InputFinished()"
-  bool input_finished_;
-
-  // The sampling frequency, extracted from the config.  Should
-  // be identical to the waveform supplied.
-  BaseFloat sampling_frequency_;
-
-  // waveform_offset_ is the number of samples of waveform that we have
-  // already discarded, i.e. thatn were prior to 'waveform_remainder_'.
-  int64 waveform_offset_;
-
-  // waveform_remainder_ is a short piece of waveform that we may need to keep
-  // after extracting all the whole frames we can (whatever length of feature
-  // will be required for the next phase of computation).
-  Vector<BaseFloat> waveform_remainder_;
-};
-
-typedef OnlineGenericBaseFeature<MfccComputer> OnlineMfcc;
-typedef OnlineGenericBaseFeature<PlpComputer> OnlinePlp;
-typedef OnlineGenericBaseFeature<FbankComputer> OnlineFbank;
-
-
-/// This class takes a Matrix<BaseFloat> and wraps it as an
-/// OnlineFeatureInterface: this can be useful where some earlier stage of
-/// feature processing has been done offline but you want to use part of the
-/// online pipeline.
-class OnlineMatrixFeature: public OnlineFeatureInterface {
- public:
-  /// Caution: this class maintains the const reference from the constructor, so
-  /// don't let it go out of scope while this object exists.
-  explicit OnlineMatrixFeature(const MatrixBase<BaseFloat> &mat): mat_(mat) { }
-
-  virtual int32 Dim() const { return mat_.NumCols(); }
-
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return 0.01f;
-  }
-
-  virtual int32 NumFramesReady() const { return mat_.NumRows(); }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-    feat->CopyFromVec(mat_.Row(frame));
-  }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return (frame + 1 == mat_.NumRows());
-  }
-
-
- private:
-  const MatrixBase<BaseFloat> &mat_;
-};
-
-
-// Note the similarity with SlidingWindowCmnOptions, but there
-// are also differences.  One which doesn't appear in the config
-// itself, because it's a difference between the setups, is that
-// in OnlineCmn, we carry over data from the previous utterance,
-// or, if no previous utterance is available, from global stats,
-// or, if previous utterances are available but the total amount
-// of data is less than prev_frames, we pad with up to "global_frames"
-// frames from the global stats.
-struct OnlineCmvnOptions {
-  int32 cmn_window;
-  int32 speaker_frames;  // must be <= cmn_window
-  int32 global_frames;  // must be <= speaker_frames.
-  bool normalize_mean;  // Must be true if normalize_variance==true.
-  bool normalize_variance;
-
-  int32 modulus;  // not configurable from command line, relates to how the
-                  // class computes the cmvn internally.  smaller->more
-                  // time-efficient but less memory-efficient.  Must be >= 1.
-  int32 ring_buffer_size;  // not configurable from command line; size of ring
-                           // buffer used for caching CMVN stats.
-  std::string skip_dims; // Colon-separated list of dimensions to skip normalization
-                         // of, e.g. 13:14:15.
-
-  OnlineCmvnOptions():
-      cmn_window(600),
-      speaker_frames(600),
-      global_frames(200),
-      normalize_mean(true),
-      normalize_variance(false),
-      modulus(20),
-      ring_buffer_size(20),
-      skip_dims("") { }
-
-  void Check() {
-    KALDI_ASSERT(speaker_frames <= cmn_window && global_frames <= speaker_frames
-                 && modulus > 0);
-  }
-
-  void Register(ParseOptions *po) {
-    po->Register("cmn-window", &cmn_window, "Number of frames of sliding "
-                 "context for cepstral mean normalization.");
-    po->Register("global-frames", &global_frames, "Number of frames of "
-                 "global-average cepstral mean normalization stats to use for "
-                 "first utterance of a speaker");
-    po->Register("speaker-frames", &speaker_frames, "Number of frames of "
-                 "previous utterance(s) from this speaker to use in cepstral "
-                 "mean normalization");
-    // we name the config string "norm-vars" for compatibility with
-    // ../featbin/apply-cmvn.cc
-    po->Register("norm-vars", &normalize_variance, "If true, do "
-                 "cepstral variance normalization in addition to cepstral mean "
-                 "normalization ");
-    po->Register("norm-mean", &normalize_mean, "If true, do mean normalization "
-                 "(note: you cannot normalize the variance but not the mean)");
-    po->Register("skip-dims", &skip_dims, "Dimensions to skip normalization of "
-                 "(colon-separated list of integers)");}
-};
-
-
-
-/** Struct OnlineCmvnState stores the state of CMVN adaptation between
-    utterances (but not the state of the computation within an utterance).  It
-    stores the global CMVN stats and the stats of the current speaker (if we
-    have seen previous utterances for this speaker), and possibly will have a
-    member "frozen_state": if the user has called the function Freeze() of class
-    OnlineCmvn, to fix the CMVN so we can estimate fMLLR on top of the fixed
-    value of cmvn.  If nonempty, "frozen_state" will reflect how we were
-    normalizing the mean and (if applicable) variance at the time when that
-    function was called.
-*/
-struct OnlineCmvnState {
-  // The following is the total CMVN stats for this speaker (up till now), in
-  // the same format.
-  Matrix<double> speaker_cmvn_stats;
-
-  // The following is the global CMVN stats, in the usual
-  // format, of dimension 2 x (dim+1), as [  sum-stats          count
-  //                                       sum-sqared-stats   0    ]
-  Matrix<double> global_cmvn_stats;
-
-  // If nonempty, contains CMVN stats representing the "frozen" state
-  // of CMVN that reflects how we were normalizing the data when the
-  // user called the Freeze() function in class OnlineCmvn.
-  Matrix<double> frozen_state;
-
-  OnlineCmvnState() { }
-
-  explicit OnlineCmvnState(const Matrix<double> &global_stats):
-      global_cmvn_stats(global_stats) { }
-
-  // Copy constructor
-  OnlineCmvnState(const OnlineCmvnState &other);
-
-  void Write(std::ostream &os, bool binary) const;
-  void Read(std::istream &is, bool binary);
-
-  // Use the default assignment operator.
-};
-
-/**
-   This class does an online version of the cepstral mean and [optionally]
-   variance, but note that this is not equivalent to the offline version.  This
-   is necessarily so, as the offline computation involves looking into the
-   future.  If you plan to use features normalized with this type of CMVN then
-   you need to train in a `matched' way, i.e. with the same type of features.
-   We normally only do so in the "online" GMM-based decoding, e.g.  in
-   online2bin/online2-wav-gmm-latgen-faster.cc; see also the script
-   steps/online/prepare_online_decoding.sh and steps/online/decode.sh.
-
-   In the steady state (in the middle of a long utterance), this class
-   accumulates CMVN statistics from the previous "cmn_window" frames (default 600
-   frames, or 6 seconds), and uses these to normalize the mean and possibly
-   variance of the current frame.
-
-   The config variables "speaker_frames" and "global_frames" relate to what
-   happens at the beginning of the utterance when we have seen fewer than
-   "cmn_window" frames of context, and so might not have very good stats to
-   normalize with.  Basically, we first augment any existing stats with up
-   to "speaker_frames" frames of stats from previous utterances of the current
-   speaker, and if this doesn't take us up to the required "cmn_window" frame
-   count, we further augment with up to "global_frames" frames of global
-   stats.  The global stats are CMVN stats accumulated from training or testing
-   data, that give us a reasonable source of mean and variance for "typical"
-   data.
- */
-class OnlineCmvn: public OnlineFeatureInterface {
- public:
-
-  //
-  // First, functions that are present in the interface:
-  //
-  virtual int32 Dim() const { return src_->Dim(); }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return src_->IsLastFrame(frame);
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds();
-  }
-
-  // The online cmvn does not introduce any additional latency.
-  virtual int32 NumFramesReady() const { return src_->NumFramesReady(); }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  //
-  // Next, functions that are not in the interface.
-  //
-
-  /// Initializer that sets the cmvn state.  If you don't have previous
-  /// utterances from the same speaker you are supposed to initialize the CMVN
-  /// state from some global CMVN stats, which you can get from summing all cmvn
-  /// stats you have in your training data using "sum-matrix".  This just gives
-  /// it a reasonable starting point at the start of the file.
-  /// If you do have previous utterances from the same speaker or at least a
-  /// similar environment, you are supposed to initialize it by calling GetState
-  /// from the previous utterance
-  OnlineCmvn(const OnlineCmvnOptions &opts,
-             const OnlineCmvnState &cmvn_state,
-             OnlineFeatureInterface *src);
-
-  /// Initializer that does not set the cmvn state:
-  /// after calling this, you should call SetState().
-  OnlineCmvn(const OnlineCmvnOptions &opts,
-             OnlineFeatureInterface *src);
-
-  // Outputs any state information from this utterance to "cmvn_state".
-  // The value of "cmvn_state" before the call does not matter: the output
-  // depends on the value of OnlineCmvnState the class was initialized
-  // with, the input feature values up to cur_frame, and the effects
-  // of the user possibly having called Freeze().
-  // If cur_frame is -1, it will just output the unmodified original
-  // state that was supplied to this object.
-  void GetState(int32 cur_frame,
-                OnlineCmvnState *cmvn_state);
-
-  // This function can be used to modify the state of the CMVN computation
-  // from outside, but must only be called before you have processed any data
-  // (otherwise it will crash).  This "state" is really just the information
-  // that is propagated between utterances, not the state of the computation
-  // inside an utterance.
-  void SetState(const OnlineCmvnState &cmvn_state);
-
-  // From this point it will freeze the CMN to what it would have been if
-  // measured at frame "cur_frame", and it will stop it from changing
-  // further. This also applies retroactively for this utterance, so if you
-  // call GetFrame() on previous frames, it will use the CMVN stats
-  // from cur_frame; and it applies in the future too if you then
-  // call OutputState() and use this state to initialize the next
-  // utterance's CMVN object.
-  void Freeze(int32 cur_frame);
-
-  virtual ~OnlineCmvn();
- private:
-
-  /// Smooth the CMVN stats "stats" (which are stored in the normal format as a
-  /// 2 x (dim+1) matrix), by possibly adding some stats from "global_stats"
-  /// and/or "speaker_stats", controlled by the config.  The best way to
-  /// understand the smoothing rule we use is just to look at the code.
-  static void SmoothOnlineCmvnStats(const MatrixBase<double> &speaker_stats,
-                                    const MatrixBase<double> &global_stats,
-                                    const OnlineCmvnOptions &opts,
-                                    MatrixBase<double> *stats);
-
-  /// Get the most recent cached frame of CMVN stats.  [If no frames
-  /// were cached, sets up empty stats for frame zero and returns that].
-  void GetMostRecentCachedFrame(int32 frame,
-                                int32 *cached_frame,
-                                Matrix<double> *stats);
-
-  /// Cache this frame of stats.
-  void CacheFrame(int32 frame, const Matrix<double> &stats);
-
-  /// Initialize ring buffer for caching stats.
-  inline void InitRingBufferIfNeeded();
-
-  /// Computes the raw CMVN stats for this frame, making use of (and updating if
-  /// necessary) the cached statistics in raw_stats_.  This means the (x,
-  /// x^2, count) stats for the last up to opts_.cmn_window frames.
-  void ComputeStatsForFrame(int32 frame,
-                            MatrixBase<double> *stats);
-
-
-  OnlineCmvnOptions opts_;
-  std::vector<int32> skip_dims_; // Skip CMVN for these dimensions.  Derived from opts_.
-  OnlineCmvnState orig_state_;   // reflects the state before we saw this
-                                 // utterance.
-  Matrix<double> frozen_state_;  // If the user called Freeze(), this variable
-                                 // will reflect the CMVN state that we froze
-                                 // at.
-
-  // The variable below reflects the raw (count, x, x^2) statistics of the
-  // input, computed every opts_.modulus frames.  raw_stats_[n / opts_.modulus]
-  // contains the (count, x, x^2) statistics for the frames from
-  // std::max(0, n - opts_.cmn_window) through n.
-  std::vector<Matrix<double>*> cached_stats_modulo_;
-  // the variable below is a ring-buffer of cached stats.  the int32 is the
-  // frame index.
-  std::vector<std::pair<int32, Matrix<double> > > cached_stats_ring_;
-
-  OnlineFeatureInterface *src_;  // Not owned here
-};
-
-
-struct OnlineSpliceOptions {
-  int32 left_context;
-  int32 right_context;
-  OnlineSpliceOptions(): left_context(4), right_context(4) { }
-  void Register(ParseOptions *po) {
-    po->Register("left-context", &left_context, "Left-context for frame "
-                 "splicing prior to LDA");
-    po->Register("right-context", &right_context, "Right-context for frame "
-                 "splicing prior to LDA");
-  }
-};
-
-class OnlineSpliceFrames: public OnlineFeatureInterface {
- public:
-  //
-  // First, functions that are present in the interface:
-  //
-  virtual int32 Dim() const {
-    return src_->Dim() * (1 + left_context_ + right_context_);
-  }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return src_->IsLastFrame(frame);
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds();
-  }
-
-  virtual int32 NumFramesReady() const;
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  //
-  // Next, functions that are not in the interface.
-  //
-  OnlineSpliceFrames(const OnlineSpliceOptions &opts,
-                     OnlineFeatureInterface *src):
-      left_context_(opts.left_context), right_context_(opts.right_context),
-      src_(src) { }
-
- private:
-  int32 left_context_;
-  int32 right_context_;
-  OnlineFeatureInterface *src_;  // Not owned here
-};
-
-/// This online-feature class implements any affine or linear transform.
-class OnlineTransform: public OnlineFeatureInterface {
- public:
-  //
-  // First, functions that are present in the interface:
-  //
-  virtual int32 Dim() const { return offset_.Dim(); }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return src_->IsLastFrame(frame);
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds();
-  }
-
-  virtual int32 NumFramesReady() const { return src_->NumFramesReady(); }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  //
-  // Next, functions that are not in the interface.
-  //
-
-  /// The transform can be a linear transform, or an affine transform
-  /// where the last column is the offset.
-  OnlineTransform(const MatrixBase<BaseFloat> &transform,
-                  OnlineFeatureInterface *src);
-
-
- private:
-  OnlineFeatureInterface *src_;  // Not owned here
-  Matrix<BaseFloat> linear_term_;
-  Vector<BaseFloat> offset_;
-};
-
-class OnlineDeltaFeature: public OnlineFeatureInterface {
- public:
-  //
-  // First, functions that are present in the interface:
-  //
-  virtual int32 Dim() const;
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return src_->IsLastFrame(frame);
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds();
-  }
-
-  virtual int32 NumFramesReady() const;
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  //
-  // Next, functions that are not in the interface.
-  //
-  OnlineDeltaFeature(const DeltaFeaturesOptions &opts,
-                     OnlineFeatureInterface *src);
-
- private:
-  OnlineFeatureInterface *src_;  // Not owned here
-  DeltaFeaturesOptions opts_;
-  DeltaFeatures delta_features_;  // This class contains just a few
-                                  // coefficients.
-};
-
-
-/// This feature type can be used to cache its input, to avoid
-/// repetition of computation in a multi-pass decoding context.
-class OnlineCacheFeature: public OnlineFeatureInterface {
- public:
-  virtual int32 Dim() const { return src_->Dim(); }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return src_->IsLastFrame(frame);
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds(); 
-  }
-
-  virtual int32 NumFramesReady() const { return src_->NumFramesReady(); }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  virtual ~OnlineCacheFeature() { ClearCache(); }
-
-  // Things that are not in the shared interface:
-
-  void ClearCache();  // this should be called if you change the underlying
-                      // features in some way.
-
-  explicit OnlineCacheFeature(OnlineFeatureInterface *src): src_(src) { }
- private:
-
-  OnlineFeatureInterface *src_;  // Not owned here
-  std::vector<Vector<BaseFloat>* > cache_;
-};
-
-
-
-
-/// This online-feature class implements combination of two feature
-/// streams (such as pitch, plp) into one stream.
-class OnlineAppendFeature: public OnlineFeatureInterface {
- public:
-  virtual int32 Dim() const { return src1_->Dim() + src2_->Dim(); }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    return (src1_->IsLastFrame(frame) || src2_->IsLastFrame(frame));
-  }
-  // Hopefully sources have the same rate
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src1_->FrameShiftInSeconds();
-  }
-
-  virtual int32 NumFramesReady() const {
-    return std::min(src1_->NumFramesReady(), src2_->NumFramesReady());
-  }
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  virtual ~OnlineAppendFeature() {  }
-
-  OnlineAppendFeature(OnlineFeatureInterface *src1,
-      OnlineFeatureInterface *src2): src1_(src1), src2_(src2) { }
- private:
-
-  OnlineFeatureInterface *src1_;
-  OnlineFeatureInterface *src2_;
-};
-
-/// @} End of "addtogroup onlinefeat"
-}  // namespace kaldi
-
-#endif  // KALDI_FEAT_ONLINE_FEATURE_H_
diff --git src/feat/pitch-functions-test.cc src/feat/pitch-functions-test.cc
deleted file mode 100644
index 26c8ae6..0000000
--- src/feat/pitch-functions-test.cc
+++ /dev/null
@@ -1,561 +0,0 @@
-// feat/pitch-functions-test.cc
-
-// Copyright    2013  Pegah Ghahremani
-//              2014  IMSL, PKU-HKUST (author: Wei Shi)
-//              2014  Yanqing Sun, Junjie Wang,
-//                    Daniel Povey, Korbinian Riedhammer
-//                    Xin Lei
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "base/kaldi-math.h"
-#include "feat/feature-plp.h"
-#include "feat/pitch-functions.h"
-#include "feat/wave-reader.h"
-#include "sys/stat.h"
-#include "sys/types.h"
-#include "base/timer.h"
-
-
-namespace kaldi {
-
-std::string ConvertIntToString(const int &number) {
-  std::stringstream ss;  // create a stringstream
-  ss << number;  // add number to the stream
-  return ss.str();  // return a string with the contents of the stream
-}
-bool DirExist(const std::string &dirname) {
-  struct stat st;
-  if (stat(dirname.c_str(), &st) != 0) {
-    KALDI_LOG << " directory " << dirname << " does not exist!";
-    return false;
-  }
-  return true;
-}
-
-static void UnitTestSimple() {
-  KALDI_LOG << "=== UnitTestSimple() ===";
-  Vector<BaseFloat> v(1000);
-  Matrix<BaseFloat> m1, m2;
-  // init with noise
-  for (int32 i = 0; i < v.Dim(); i++) {
-    v(i) = (abs(i * 433024253) % 65535) - (65535 / 2);
-  }
-  KALDI_LOG << "<<<=== Just make sure it runs... Nothing is compared";
-  // trying to compute and process pitch with same opts as baseline.
-  PitchExtractionOptions op1;
-  ProcessPitchOptions op2;
-  ComputeAndProcessKaldiPitch(op1, op2, v, &m1);
-  KALDI_LOG << "Test passed :)";
-}
-
-
-// Make sure that doing a calculation on the whole waveform gives
-// the same results as doing on the waveform broken into pieces.
-static void UnitTestPieces() {
-  KALDI_LOG << "=== UnitTestPieces() ===\n";
-  for (int32 n = 0; n < 10; n++) {
-    // the parametrization object
-    PitchExtractionOptions op1;
-    ProcessPitchOptions op2;
-    op2.delta_pitch_noise_stddev = 0.0;  // to avoid mismatch of delta_log_pitch
-                                         // brought by rand noise.
-    op1.nccf_ballast_online = true;  // this is necessary for the computation
-    // to be identical regardless how many pieces we break the signal into.
-
-    int32 size = 10000 + rand() % 50000;
-
-    Vector<BaseFloat> v(size);
-    // init with noise plus a sine-wave whose frequency is changing randomly.
-
-    double cur_freq = 200.0, normalized_time = 0.0;
-
-    for (int32 i = 0; i < size; i++) {
-      v(i) = RandGauss() + cos(normalized_time * M_2PI);
-      cur_freq += RandGauss();  // let the frequency wander a little.
-      if (cur_freq < 100.0) cur_freq = 100.0;
-      if (cur_freq > 300.0) cur_freq = 300.0;
-      normalized_time += cur_freq / op1.samp_freq;
-    }
-
-    Matrix<BaseFloat> m1, m1p;
-
-    // trying to have same opts as baseline.
-    ComputeKaldiPitch(op1, v, &m1);
-    ProcessPitch(op2, m1, &m1p);
-
-    Matrix<BaseFloat> m2, m2p;
-
-    { // compute it online with multiple pieces.
-      OnlinePitchFeature pitch_extractor(op1);
-      OnlineProcessPitch process_pitch(op2, &pitch_extractor);
-      int32 start_samp = 0;
-      while (start_samp < v.Dim()) {
-        int32 num_samp = rand() % (v.Dim() + 1 - start_samp);
-        SubVector<BaseFloat> v_part(v, start_samp, num_samp);
-        pitch_extractor.AcceptWaveform(op1.samp_freq, v_part);
-        start_samp += num_samp;
-      }
-      pitch_extractor.InputFinished();
-      int32 num_frames = pitch_extractor.NumFramesReady();
-      m2.Resize(num_frames, 2);
-      m2p.Resize(num_frames, process_pitch.Dim());
-      for (int32 frame = 0; frame < num_frames; frame++) {
-        SubVector<BaseFloat> row(m2, frame);
-        pitch_extractor.GetFrame(frame, &row);
-        SubVector<BaseFloat> rowp(m2p, frame);
-        process_pitch.GetFrame(frame, &rowp);
-      }
-    }
-    AssertEqual(m1, m2);
-    if (!ApproxEqual(m1p, m2p)) {
-      KALDI_ERR << "Post-processed pitch differs: " << m1p << " vs. " << m2p;
-    }
-    KALDI_LOG << "Test passed :)\n";
-  }
-}
-
-// Make sure that the delayed output matches the non-delayed
-// version in the online scenario.
-static void UnitTestDelay() {
-  KALDI_LOG << "=== UnitTestDelay() ===\n";
-  for (int32 n = 0; n < 10; n++) {
-    // the parametrization object
-    PitchExtractionOptions ext_opt;
-    ProcessPitchOptions pro_opt1, pro_opt2;
-    pro_opt1.delta_pitch_noise_stddev = 0.0;  // to avoid mismatch of delta_log_pitch
-                                              // brought by rand noise.
-    pro_opt2.delta_pitch_noise_stddev = 0.0;  // to avoid mismatch of delta_log_pitch
-                                              // brought by rand noise.
-    pro_opt2.delay = rand() % 50;
-    ext_opt.nccf_ballast_online = true;  // this is necessary for the computation
-    // to be identical regardless how many pieces we break the signal into.
-
-    int32 size = 10000 + rand() % 50000;
-
-    Vector<BaseFloat> v(size);
-    // init with noise plus a sine-wave whose frequency is changing randomly.
-
-    double cur_freq = 200.0, normalized_time = 0.0;
-
-    for (int32 i = 0; i < size; i++) {
-      v(i) = RandGauss() + cos(normalized_time * M_2PI);
-      cur_freq += RandGauss();  // let the frequency wander a little.
-      if (cur_freq < 100.0) cur_freq = 100.0;
-      if (cur_freq > 300.0) cur_freq = 300.0;
-      normalized_time += cur_freq / ext_opt.samp_freq;
-    }
-
-    Matrix<BaseFloat> m1, m2;
-    // compute it online with multiple pieces.
-    OnlinePitchFeature pitch_extractor(ext_opt);
-    OnlineProcessPitch pitch_processor(pro_opt1, &pitch_extractor);
-    OnlineProcessPitch pitch_processor_delayed(pro_opt2, &pitch_extractor);
-    int32 start_samp = 0;
-    while (start_samp < v.Dim()) {
-      int32 num_samp = rand() % (v.Dim() + 1 - start_samp);
-      SubVector<BaseFloat> v_part(v, start_samp, num_samp);
-      pitch_extractor.AcceptWaveform(ext_opt.samp_freq, v_part);
-      start_samp += num_samp;
-    }
-    pitch_extractor.InputFinished();
-
-    int32 num_frames = pitch_processor.NumFramesReady();
-    m1.Resize(num_frames, pitch_processor.Dim());
-    for (int32 frame = 0; frame < num_frames; frame++) {
-      SubVector<BaseFloat> rowp(m1, frame);
-      pitch_processor.GetFrame(frame, &rowp);
-    }
-
-    int32 num_frames_delayed = pitch_processor_delayed.NumFramesReady();
-    m2.Resize(num_frames_delayed, pitch_processor_delayed.Dim());
-    for (int32 frame = 0; frame < num_frames_delayed; frame++) {
-      SubVector<BaseFloat> rowp(m2, frame);
-      pitch_processor_delayed.GetFrame(frame, &rowp);
-    }
-
-    KALDI_ASSERT(num_frames_delayed == num_frames + pro_opt2.delay);
-    SubMatrix<BaseFloat> m3(m2, pro_opt2.delay, num_frames, 0, m2.NumCols());
-    if (!ApproxEqual(m1, m3)) {
-      KALDI_ERR << "Post-processed pitch differs: " << m1 << " vs. " << m3;
-    }
-    KALDI_LOG << "Test passed :)\n";
-  }
-}
-
-extern bool pitch_use_naive_search; // was declared in pitch-functions.cc
-
-// Make sure that doing a calculation on the whole waveform gives
-// the same results as doing on the waveform broken into pieces.
-static void UnitTestSearch() {
-  KALDI_LOG << "=== UnitTestSearch() ===\n";
-  for (int32 n = 0; n < 3; n++) {
-    // the parametrization object
-    PitchExtractionOptions op;
-    op.nccf_ballast_online = true;  // this is necessary for the computation
-    // to be identical regardless how many pieces we break the signal into.
-
-    int32 size = 10000 + rand() % 10000;
-
-    Vector<BaseFloat> v(size);
-    // init with noise plus a sine-wave whose frequency is changing randomly.
-
-    double cur_freq = 200.0, normalized_time = 0.0;
-
-    for (int32 i = 0; i < size; i++) {
-      v(i) = RandGauss() + cos(normalized_time * M_2PI);
-      cur_freq += RandGauss();  // let the frequency wander a little.
-      if (cur_freq < 100.0) cur_freq = 100.0;
-      if (cur_freq > 300.0) cur_freq = 300.0;
-      normalized_time += cur_freq / op.samp_freq;
-    }
-
-    Matrix<BaseFloat> m1;
-    ComputeKaldiPitch(op, v, &m1);
-
-    pitch_use_naive_search = true;
-
-    Matrix<BaseFloat> m2;
-    ComputeKaldiPitch(op, v, &m2);
-
-    pitch_use_naive_search = false;
-
-    AssertEqual(m1, m2, 1.0e-08);  // should be identical.
-  }
-  KALDI_LOG << "Test passed :)\n";
-}
-
-static void UnitTestComputeGPE() {
-  KALDI_LOG << "=== UnitTestComputeGPE ===\n";
-  int32 wrong_pitch = 0, tot_voiced = 0, tot_unvoiced = 0, num_frames = 0;
-  BaseFloat tol = 0.1, avg_d_kpitch = 0, real_pitch = 0;
-  for (int32 i = 1; i < 11; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f" + ConvertIntToString(i) + "nw0000";
-    } else {
-      num = "m" + ConvertIntToString(i-5) + "nw0000";
-    }
-    Matrix<BaseFloat> gross_pitch;
-    std::string pitchfile = "keele/keele-true-lags/"+num+".txt";
-    std::ifstream pitch(pitchfile.c_str());
-    gross_pitch.Read(pitch, false);
-    Matrix<BaseFloat> kaldi_pitch;
-    std::string kfile = "keele/tmp/+"+num+"-kaldi.txt";
-    std::ifstream kpitch(kfile.c_str());
-    kaldi_pitch.Read(kpitch, false);
-    num_frames = std::min(kaldi_pitch.NumRows(),gross_pitch.NumRows());
-    for (int32 j = 1; j < num_frames; j++) {
-      if (gross_pitch(j,0) > 0.0) {
-        tot_voiced++;
-        real_pitch = 20000.0/gross_pitch(j,0);
-        if (fabs((real_pitch - kaldi_pitch(j,1))/real_pitch) > tol)
-          wrong_pitch++;
-      } else if (gross_pitch(j,0) == 0.0 && gross_pitch(j-1,0) == 0.0) {
-        tot_unvoiced++;
-        avg_d_kpitch += fabs(kaldi_pitch(j,1) - kaldi_pitch(j-1,1));
-      }
-    }
-  }
-  BaseFloat GPE = 1.0 * wrong_pitch / tot_voiced;
-  KALDI_LOG << " Gross Pitch Error with Rel.Error " << tol << " is " << GPE;
-  KALDI_LOG << "Average Kaldi delta_pitch for unvoiced regions " << avg_d_kpitch/tot_unvoiced;
-}
-
-// Compare pitch using Kaldi pitch tracker on KEELE corpora
-static void UnitTestKeele() {
-  KALDI_LOG << "=== UnitTestKeele() ===";
-  for (int32 i = 1; i < 11; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f" + ConvertIntToString(i) + "nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    } else {
-      num = "m" + ConvertIntToString(i-5) + "nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    }
-    KALDI_LOG << "--- " << wavefile << " ---";
-    std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    KALDI_ASSERT(wave.Data().NumRows() == 1);
-    SubVector<BaseFloat> waveform(wave.Data(), 0);
-    // use pitch code with default configuration..
-    PitchExtractionOptions op;
-    op.nccf_ballast = 1;
-    op.penalty_factor = 5;
-    // compute pitch.
-    Matrix<BaseFloat> m;
-    ComputeKaldiPitch(op, waveform, &m);
-    std::string outfile = "keele/tmp/+"+num+"-kaldi.txt";
-    std::ofstream os(outfile.c_str());
-    m.Write(os, false);
-  }
-}
-/* change freq_weight to investigate the results */
-static void UnitTestPenaltyFactor() {
-  KALDI_LOG << "=== UnitTestPenaltyFactor() ===";
-  for (int32 k = 1; k < 5; k++) {
-    for (int32 i = 1; i < 4; i++) {
-      std::string wavefile;
-      std::string num;
-      if (i < 6) {
-        num = "f"+ConvertIntToString(i)+"nw0000";
-        wavefile = "keele/16kHz/"+num+".wav";
-      } else {
-        num = "m"+ConvertIntToString(i-5)+"nw0000";
-        wavefile = "keele/16kHz/"+num+".wav";
-      }
-      KALDI_LOG << "--- " << wavefile << " ---";
-      std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-      WaveData wave;
-      wave.Read(is);
-      KALDI_ASSERT(wave.Data().NumRows() == 1);
-      SubVector<BaseFloat> waveform(wave.Data(), 0);
-      // use pitch code with default configuration..
-      PitchExtractionOptions op;
-      op.penalty_factor = k * 0.05;
-      op.nccf_ballast = 0.1;
-      // compute pitch.
-      Matrix<BaseFloat> m;
-      ComputeKaldiPitch(op, waveform, &m);
-      std::string penaltyfactor = ConvertIntToString(k);
-      std::string outfile = "keele/tmp/+"+num+"-kaldi-penalty-"+penaltyfactor+".txt";
-      std::ofstream os(outfile.c_str());
-      m.Write(os, false);
-    }
-  }
-}
-static void UnitTestKeeleNccfBallast() {
-  KALDI_LOG << "=== UnitTestKeeleNccfBallast() ===";
-  for (int32 k = 1; k < 10; k++) {
-    for (int32 i = 1; i < 2; i++) {
-      std::string wavefile;
-      std::string num;
-      if (i < 6) {
-        num = "f"+ConvertIntToString(i)+"nw0000";
-        wavefile = "keele/16kHz/"+num+".wav";
-      } else {
-        num = "m"+ConvertIntToString(i-5)+"nw0000";
-        wavefile = "keele/16kHz/"+num+".wav";
-      }
-      KALDI_LOG << "--- " << wavefile << " ---";
-      std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-      WaveData wave;
-      wave.Read(is);
-      KALDI_ASSERT(wave.Data().NumRows() == 1);
-      SubVector<BaseFloat> waveform(wave.Data(), 0);
-      // use pitch code with default configuration..
-      PitchExtractionOptions op;
-      op.nccf_ballast = 0.05 * k;
-      KALDI_LOG << " nccf_ballast " << op.nccf_ballast << std::endl;
-      // compute pitch.
-      Matrix<BaseFloat> m;
-      ComputeKaldiPitch(op, waveform, &m);
-      std::string nccfballast = ConvertIntToString(op.nccf_ballast);
-      std::string outfile = "keele/tmp/+"+num
-        +"-kaldi-nccf-ballast-"+nccfballast+".txt";
-      std::ofstream os(outfile.c_str());
-      m.Write(os, false);
-    }
-  }
-}
-
-static void UnitTestPitchExtractionSpeed() {
-  KALDI_LOG << "=== UnitTestPitchExtractionSpeed() ===";
-  // use pitch code with default configuration..
-  PitchExtractionOptions op;
-  op.nccf_ballast = 0.1;
-  op.lowpass_cutoff = 1000;
-  for (int32 i = 1; i < 2; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f"+ConvertIntToString(i)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    } else {
-      num = "m"+ConvertIntToString(i-5)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    }
-    KALDI_LOG << "--- " << wavefile << " ---";
-    std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    KALDI_ASSERT(wave.Data().NumRows() == 1);
-    SubVector<BaseFloat> waveform(wave.Data(), 0);
-    // compute pitch.
-    int test_num = 10;
-    Matrix<BaseFloat> m;
-    Timer timer;
-    for (int32 t = 0; t < test_num; t++)
-      ComputeKaldiPitch(op, waveform, &m);
-    double tot_time = timer.Elapsed(),
-        speech_time = test_num * waveform.Dim() / wave.SampFreq();
-    KALDI_LOG << " Pitch extraction time per second of speech is "
-              << (tot_time / speech_time) << " seconds " << std::endl;
-  }
-}
-static void UnitTestPitchExtractorCompareKeele() {
-  KALDI_LOG << "=== UnitTestPitchExtractorCompareKeele() ===";
-  // use pitch code with default configuration..
-  PitchExtractionOptions op;
-  op.nccf_ballast = 0.1;
-  for (int32 i = 1; i < 11; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f"+ConvertIntToString(i)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    } else {
-      num = "m"+ConvertIntToString(i-5)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    }
-    KALDI_LOG << "--- " << wavefile << " ---";
-    std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    KALDI_ASSERT(wave.Data().NumRows() == 1);
-    SubVector<BaseFloat>  waveform(wave.Data(), 0);
-    // compute pitch.
-    Matrix<BaseFloat> m;
-    ComputeKaldiPitch(op, waveform, &m);
-    std::string outfile = "keele/tmp/+"+num+"-speedup-kaldi1.txt";
-    std::ofstream os(outfile.c_str());
-    m.Write(os, false);
-  }
-}
-void UnitTestDiffSampleRate() {
-  // you need to use sox to change sampling rate
-  // e.g. sox -r 10k input.wav output.wav
-  // put them in keele/(samp_rate in kHz)+"kHz" e.g. keele/10kHz
-  int sample_rate = 16000;
-  PitchExtractionOptions op;
-  op.samp_freq = static_cast<double>(sample_rate);
-  op.lowpass_cutoff = 1000;
-  op.max_f0 = 400;
-  std::string samp_rate = ConvertIntToString(sample_rate/1000);
-  for (int32 i = 1; i < 11; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f"+ConvertIntToString(i)+"nw0000";
-      wavefile = "keele/"+samp_rate+"kHz/"+num+".wav";
-    } else {
-      num = "m"+ConvertIntToString(i-5)+"nw0000";
-      wavefile = "keele/"+samp_rate+"kHz/"+num+".wav";
-    }
-    KALDI_LOG << "--- " << wavefile << " ---";
-    std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    KALDI_ASSERT(wave.Data().NumRows() == 1);
-    SubVector<BaseFloat> waveform(wave.Data(), 0);
-    Matrix<BaseFloat> m;
-    ComputeKaldiPitch(op, waveform, &m);
-    std::string outfile = "keele/tmp/+"+num+"-kaldi-samp-freq-"+samp_rate+"kHz.txt";
-    std::ofstream os(outfile.c_str());
-    m.Write(os, false);
-  }
-}
-void UnitTestProcess() {
-  for (int32 i = 1; i < 11; i++) {
-    std::string wavefile;
-    std::string num;
-    if (i < 6) {
-      num = "f"+ConvertIntToString(i)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    } else {
-      num = "m"+ConvertIntToString(i-5)+"nw0000";
-      wavefile = "keele/16kHz/"+num+".wav";
-    }
-    KALDI_LOG << "--- " << wavefile << " ---";
-    std::ifstream is(wavefile.c_str(), std::ios_base::binary);
-    WaveData wave;
-    wave.Read(is);
-    KALDI_ASSERT(wave.Data().NumRows() == 1);
-    SubVector<BaseFloat> waveform(wave.Data(), 0);
-    PitchExtractionOptions op;
-    op.lowpass_cutoff = 1000;
-    op.nccf_ballast = 0.1;
-    op.max_f0 = 400;
-    Matrix<BaseFloat> m, m2;
-    ComputeKaldiPitch(op, waveform, &m);
-    ProcessPitchOptions postprop_op;
-    // postprop_op.pov_nonlinearity = 2;
-    // Use zero noise, or the features won't be identical.
-    postprop_op.delta_pitch_noise_stddev = 0.0;
-    ProcessPitch(postprop_op, m, &m2);
-
-    std::string outfile = "keele/tmp/+"+num+"-processed-kaldi.txt";
-    std::ofstream os(outfile.c_str());
-    m2.Write(os, false);
-  }
-}
-
-static void UnitTestFeatNoKeele() {
-  UnitTestSimple();
-  UnitTestPieces();
-  UnitTestDelay();
-  UnitTestSearch();
-}
-
-static void UnitTestFeatWithKeele() {
-  UnitTestProcess();
-  UnitTestKeele();
-  UnitTestComputeGPE();
-  UnitTestPenaltyFactor();
-  UnitTestKeeleNccfBallast();
-  UnitTestPitchExtractionSpeed();
-  UnitTestPitchExtractorCompareKeele();
-  UnitTestDiffSampleRate();
-}
-
-}  // namespace kaldi
-
-int main() {
-  using namespace kaldi;
-
-  SetVerboseLevel(3);
-  try {
-    UnitTestFeatNoKeele();
-    if (DirExist("keele/16kHz")) {
-      UnitTestFeatWithKeele();
-    } else {
-      KALDI_LOG
-          << "Not running tests that require the Keele database, "
-          << "please ask g.meyer@liverpool.ac.uk for the database if you need it.\n"
-          << "Once you have the keele/ subdirectory, containing *.{pel,pet,pev,raw,wav}, do this:\n"
-          << "cd keele; mkdir -p 16kHz; mkdir -p tmp; for x in *.wav; do \n"
-          << "sox $x -r 16000 16kHz/$x; done  \n"
-          << "mkdir -p keele-true-lags; for f in *.pev; do \n"
-          << "out_f=keele-true-lags/$(echo $f | sed s:pev:txt:); ( echo ' ['; len=`cat $f | wc -l`; \n"
-          << "head -n $(($len-1)) $f | tail -n $(($len-14)) ; echo -n ']') >$out_f; done \n"
-          << "\n"
-          << "Note: the GPE reported in paper is computed using pseudo-ground-truth pitch obtained\n"
-          << "by voting among the pitch trackers mentioned in the paper.\n";
-    }
-    KALDI_LOG << "Tests succeeded.";
-    return 0;
-  } catch(const std::exception &e) {
-    KALDI_ERR << e.what();
-    return 1;
-  }
-}
diff --git src/feat/pitch-functions.cc src/feat/pitch-functions.cc
deleted file mode 100644
index 12dd503..0000000
--- src/feat/pitch-functions.cc
+++ /dev/null
@@ -1,1632 +0,0 @@
-// feat/pitch-functions.cc
-
-// Copyright    2013  Pegah Ghahremani
-//              2014  IMSL, PKU-HKUST (author: Wei Shi)
-//              2014  Yanqing Sun, Junjie Wang,
-//                    Daniel Povey, Korbinian Riedhammer
-//                    Xin Lei
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include <algorithm>
-#include <limits>
-
-#include "feat/feature-functions.h"
-#include "feat/mel-computations.h"
-#include "feat/online-feature.h"
-#include "feat/pitch-functions.h"
-#include "feat/resample.h"
-#include "matrix/matrix-functions.h"
-
-namespace kaldi {
-
-/**
-   This function processes the NCCF n to a POV feature f by applying the formula
-     f = (1.0001 - n)^0.15  - 1.0
-   This is a nonlinear function designed to make the output reasonably Gaussian
-   distributed.  Before doing this, the NCCF distribution is in the range [-1,
-   1] but has a strong peak just before 1.0, which this function smooths out.
-*/
-
-BaseFloat NccfToPovFeature(BaseFloat n) {
-  if (n > 1.0) {
-    n = 1.0;
-  } else if (n < -1.0) {
-    n = -1.0;
-  }
-  BaseFloat f = pow((1.0001 - n), 0.15) - 1.0;
-  KALDI_ASSERT(f - f == 0);  // check for NaN,inf.
-  return f;
-}
-
-/**
-   This function processes the NCCF n to a reasonably accurate probability
-   of voicing p by applying the formula:
-
-      n' = fabs(n)
-      r = -5.2 + 5.4 * exp(7.5 * (n' - 1.0)) +
-           4.8 * n' - 2.0 * exp(-10.0 * n') + 4.2 * exp(20.0 * (n' - 1.0));
-      p = 1.0 / (1 + exp(-1.0 * r));
-
-   How did we get this formula?  We plotted the empirical log-prob-ratio of voicing
-    r = log( p[voiced] / p[not-voiced] )
-   [on the Keele database where voicing is marked], as a function of the NCCF at
-   the delay picked by our algorithm.  This was done on intervals of the NCCF, so
-   we had enough statistics to get that ratio.  The NCCF covers [-1, 1]; almost
-   all of the probability mass is on [0, 1] but the empirical POV seems fairly
-   symmetric with a minimum near zero, so we chose to make it a function of n' = fabs(n).
-   
-   Then we manually tuned a function (the one you see above) that approximated
-   the log-prob-ratio of voicing fairly well as a function of the absolute-value
-   NCCF n'; however, wasn't a very exact match since we were also trying to make
-   the transformed NCCF fairly Gaussian distributed, with a view to using it as
-   a feature-- an idea we later abandoned after a simpler formula worked better.
- */
-BaseFloat NccfToPov(BaseFloat n) {
-  BaseFloat ndash = fabs(n);
-  if (ndash > 1.0) ndash = 1.0;  // just in case it was slightly outside [-1, 1]
-
-  BaseFloat r = -5.2 + 5.4 * Exp(7.5 * (ndash - 1.0)) + 4.8 * ndash -
-                2.0 * Exp(-10.0 * ndash) + 4.2 * Exp(20.0 * (ndash - 1.0));
-  // r is the approximate log-prob-ratio of voicing, log(p/(1-p)).
-  BaseFloat p = 1.0 / (1 + Exp(-1.0 * r));
-  KALDI_ASSERT(p - p == 0);  // Check for NaN/inf
-  return p;
-}
-
-/**
-   This function computes some dot products that are required
-   while computing the NCCF.
-   For each integer lag from start to end-1, this function
-   outputs to (*inner_prod)(lag - start), the dot-product
-   of a window starting at 0 with a window starting at
-   lag.  All windows are of length nccf_window_size.  It
-   outputs to (*norm_prod)(lag - start), e1 * e2, where
-   e1 is the dot-product of the un-shifted window with itself,
-   and d2 is the dot-product of the window shifted by "lag"
-   with itself.
- */
-void ComputeCorrelation(const VectorBase<BaseFloat> &wave,
-                        int32 first_lag, int32 last_lag,
-                        int32 nccf_window_size,
-                        VectorBase<BaseFloat> *inner_prod,
-                        VectorBase<BaseFloat> *norm_prod) {
-  Vector<BaseFloat> zero_mean_wave(wave);
-  // TODO: possibly fix this, the mean normalization is done in a strange way.
-  SubVector<BaseFloat> wave_part(wave, 0, nccf_window_size);
-  // subtract mean-frame from wave
-  zero_mean_wave.Add(-wave_part.Sum() / nccf_window_size);
-  BaseFloat e1, e2, sum;
-  SubVector<BaseFloat> sub_vec1(zero_mean_wave, 0, nccf_window_size);
-  e1 = VecVec(sub_vec1, sub_vec1);
-  for (int32 lag = first_lag; lag <= last_lag; lag++) {
-    SubVector<BaseFloat> sub_vec2(zero_mean_wave, lag, nccf_window_size);
-    e2 = VecVec(sub_vec2, sub_vec2);
-    sum = VecVec(sub_vec1, sub_vec2);
-    (*inner_prod)(lag - first_lag) = sum;
-    (*norm_prod)(lag - first_lag) = e1 * e2;
-  }
-}
-
-/**
-   Computes the NCCF as a fraction of the numerator term (a dot product between
-   two vectors) and a denominator term which equals sqrt(e1*e2 + nccf_ballast)
-   where e1 and e2 are both dot-products of bits of the wave with themselves,
-   and e1*e2 is supplied as "norm_prod".  These quantities are computed by
-   "ComputeCorrelation".
-*/
-void ComputeNccf(const VectorBase<BaseFloat> &inner_prod,
-                 const VectorBase<BaseFloat> &norm_prod,
-                 BaseFloat nccf_ballast,
-                 VectorBase<BaseFloat> *nccf_vec) {
-  KALDI_ASSERT(inner_prod.Dim() == norm_prod.Dim() &&
-               inner_prod.Dim() == nccf_vec->Dim());
-  for (int32 lag = 0; lag < inner_prod.Dim(); lag++) {
-    BaseFloat numerator = inner_prod(lag),
-        denominator = pow(norm_prod(lag) + nccf_ballast, 0.5),
-        nccf;
-    if (denominator != 0.0) {
-      nccf = numerator / denominator;
-    } else {
-      KALDI_ASSERT(numerator == 0.0);
-      nccf = 0.0;
-    }
-    KALDI_ASSERT(nccf < 1.01 && nccf > -1.01);
-    (*nccf_vec)(lag) = nccf;
-  }
-}
-
-/**
-   This function selects the lags at which we measure the NCCF: we need
-   to select lags from 1/max_f0 to 1/min_f0, in a geometric progression
-   with ratio 1 + d.
- */
-void SelectLags(const PitchExtractionOptions &opts,
-                Vector<BaseFloat> *lags) {
-  // choose lags relative to acceptable pitch tolerance
-  BaseFloat min_lag = 1.0 / opts.max_f0, max_lag = 1.0 / opts.min_f0;
-
-  std::vector<BaseFloat> tmp_lags;
-  for (BaseFloat lag = min_lag; lag <= max_lag; lag *= 1.0 + opts.delta_pitch)
-    tmp_lags.push_back(lag);
-  lags->Resize(tmp_lags.size());
-  std::copy(tmp_lags.begin(), tmp_lags.end(), lags->Data());
-}
-
-
-/**
-   This function computes the local-cost for the Viterbi computation,
-   see eq. (5) in the paper.
-   @param  opts         The options as provided by the user
-   @param  nccf_pitch   The nccf as computed for the pitch computation (with ballast).
-   @param  lags         The log-spaced lags at which nccf_pitch is sampled.
-   @param  local_cost   We output the local-cost to here.
-*/
-void ComputeLocalCost(const VectorBase<BaseFloat> &nccf_pitch,
-                      const VectorBase<BaseFloat> &lags,
-                      const PitchExtractionOptions &opts,
-                      VectorBase<BaseFloat> *local_cost) {
-  // from the paper, eq. 5, local_cost = 1 - Phi(t,i)(1 - soft_min_f0 L_i)
-  // nccf is the nccf on this frame measured at the lags in "lags".
-  KALDI_ASSERT(nccf_pitch.Dim() == local_cost->Dim() &&
-               nccf_pitch.Dim() == lags.Dim());
-  local_cost->Set(1.0);
-  // add the term -Phi(t,i):
-  local_cost->AddVec(-1.0, nccf_pitch);
-  // add the term soft_min_f0 Phi(t,i) L_i
-  local_cost->AddVecVec(opts.soft_min_f0, lags, nccf_pitch, 1.0);
-}
-
-
-
-// class PitchFrameInfo is used inside class OnlinePitchFeatureImpl.
-// It stores the information we need to keep around for a single frame
-// of the pitch computation.
-class PitchFrameInfo {
- public:
-  /// This function resizes the arrays for this object and updates the reference
-  /// counts for the previous object (by decrementing those reference counts
-  /// when we destroy a StateInfo object).  A StateInfo object is considered to
-  /// be destroyed when we delete it, not when its reference counts goes to
-  /// zero.
-  void Cleanup(PitchFrameInfo *prev_frame);
-
-  /// This function may be called for the last (most recent) PitchFrameInfo
-  /// object with the best state (obtained from the externally held
-  /// forward-costs). It traces back as far as needed to set the
-  /// cur_best_state_, and as it's going it sets the lag-index and pov_nccf in
-  /// pitch_pov_iter, which when it's called is an iterator to where to put the
-  /// info for the final state; the iterator will be decremented inside this
-  /// function. 
-  void SetBestState(int32 best_state,
-      std::vector<std::pair<int32, BaseFloat> > &lag_nccf);
-
-  /// This function may be called on the last (most recent) PitchFrameInfo
-  /// object; it computes how many frames of latency there is because the
-  /// traceback has not yet settled on a single value for frames in the past.
-  /// It actually returns the minimum of max_latency and the actual latency,
-  /// which is an optimization because we won't care about latency past
-  /// a user-specified maximum latency.
-  int32 ComputeLatency(int32 max_latency);
-
-  /// This function updates
-  bool UpdatePreviousBestState(PitchFrameInfo *prev_frame);
-
-  /// This constructor is used for frame -1; it sets the costs to be all zeros
-  /// the pov_nccf's to zero and the backpointers to -1.
-  explicit PitchFrameInfo(int32 num_states);
-
-  /// This constructor is used for subsequent frames (not -1).
-  PitchFrameInfo(PitchFrameInfo *prev);
-
-  /// Record the nccf_pov value.
-  ///  @param  nccf_pov     The nccf as computed for the POV computation (without ballast).
-  void SetNccfPov(const VectorBase<BaseFloat> &nccf_pov);
-
-  /// This constructor is used for frames apart from frame -1; the bulk of
-  /// the Viterbi computation takes place inside this constructor.
-  ///  @param  opts         The options as provided by the user
-  ///  @param  nccf_pitch   The nccf as computed for the pitch computation
-  ///                       (with ballast).
-  ///  @param  nccf_pov     The nccf as computed for the POV computation
-  ///                       (without ballast).
-  ///  @param  lags         The log-spaced lags at which nccf_pitch and
-  ///                       nccf_pov are sampled.
-  ///  @param  prev_frame_forward_cost   The forward-cost vector for the
-  ///                       previous frame.
-  ///  @param  index_info   A pointer to a temporary vector used by this function
-  ///  @param  this_forward_cost   The forward-cost vector for this frame
-  ///                       (to be computed).
-  void ComputeBacktraces(const PitchExtractionOptions &opts,
-                         const VectorBase<BaseFloat> &nccf_pitch, 
-                         const VectorBase<BaseFloat> &lags,
-                         const VectorBase<BaseFloat> &prev_forward_cost,
-                         std::vector<std::pair<int32, int32> > *index_info,
-                         VectorBase<BaseFloat> *this_forward_cost);
- private:
-  // struct StateInfo is the information we keep for a single one of the
-  // log-spaced lags, for a single frame.  This is a state in the Viterbi
-  // computation.
-  struct StateInfo {
-    /// The state index on the previous frame that is the best preceding state
-    /// for this state.
-    int32 backpointer;
-    /// the version of the NCCF we keep for the POV computation (without the
-    /// ballast term).
-    BaseFloat pov_nccf;
-    StateInfo(): backpointer(0), pov_nccf(0.0) { }
-  };
-  std::vector<StateInfo> state_info_;
-  /// the state index of the first entry in "state_info"; this will initially be
-  /// zero, but after cleanup might be nonzero.
-  int32 state_offset_;
-
-  /// The current best state in the backtrace from the end.
-  int32 cur_best_state_;
-
-  /// The structure for the previous frame.
-  PitchFrameInfo *prev_info_;
-};
-
-
-// This constructor is used for frame -1; it sets the costs to be all zeros
-// the pov_nccf's to zero and the backpointers to -1.
-PitchFrameInfo::PitchFrameInfo(int32 num_states)
-    :state_info_(num_states), state_offset_(0),
-    cur_best_state_(-1), prev_info_(NULL) { }
-
-
-bool pitch_use_naive_search = false;  // This is used in unit-tests.
-
-
-PitchFrameInfo::PitchFrameInfo(PitchFrameInfo *prev_info):
-    state_info_(prev_info->state_info_.size()), state_offset_(0),
-    cur_best_state_(-1), prev_info_(prev_info) { }
-
-void PitchFrameInfo::SetNccfPov(const VectorBase<BaseFloat> &nccf_pov) {
-  int32 num_states = nccf_pov.Dim();
-  KALDI_ASSERT(num_states == state_info_.size());
-  for (int32 i = 0; i < num_states; i++)
-    state_info_[i].pov_nccf = nccf_pov(i);
-}
-
-void PitchFrameInfo::ComputeBacktraces(
-    const PitchExtractionOptions &opts,
-    const VectorBase<BaseFloat> &nccf_pitch, 
-    const VectorBase<BaseFloat> &lags,
-    const VectorBase<BaseFloat> &prev_forward_cost_vec,
-    std::vector<std::pair<int32, int32> > *index_info,
-    VectorBase<BaseFloat> *this_forward_cost_vec) {
-  int32 num_states = nccf_pitch.Dim();
-
-  Vector<BaseFloat> local_cost(num_states, kUndefined);
-  ComputeLocalCost(nccf_pitch, lags, opts, &local_cost);
-
-  const BaseFloat delta_pitch_sq = pow(Log(1.0 + opts.delta_pitch), 2.0),
-      inter_frame_factor = delta_pitch_sq * opts.penalty_factor;
-
-  // index local_cost, prev_forward_cost and this_forward_cost using raw pointer
-  // indexing not operator (), since this is the very inner loop and a lot of
-  // time is taken here.
-  const BaseFloat *prev_forward_cost = prev_forward_cost_vec.Data();
-  BaseFloat *this_forward_cost = this_forward_cost_vec->Data();
-
-  if (index_info->empty())
-    index_info->resize(num_states);
-
-  // make it a reference for more concise indexing.
-  std::vector<std::pair<int32, int32> > &bounds = *index_info;
-
-  /* bounds[i].first will be a lower bound on the backpointer for state i,
-     bounds[i].second will be an upper bound on it.  We progressively tighten
-     these bounds till we know the backpointers exactly.
-  */
-
-  if (pitch_use_naive_search) {
-    // This branch is only taken in unit-testing code.
-    for (int32 i = 0; i < num_states; i++) {
-      BaseFloat best_cost = std::numeric_limits<BaseFloat>::infinity();
-      int32 best_j = -1;
-      for (int32 j = 0; j < num_states; j++) {
-        BaseFloat this_cost = (j - i) * (j - i) * inter_frame_factor
-            + prev_forward_cost[j];
-        if (this_cost < best_cost) {
-          best_cost = this_cost;
-          best_j = j;
-        }
-      }
-      this_forward_cost[i] = best_cost;
-      state_info_[i].backpointer = best_j;
-    }
-  } else {
-    int32 last_backpointer = 0;
-    for (int32 i = 0; i < num_states; i++) {
-      int32 start_j = last_backpointer;
-      BaseFloat best_cost = (start_j - i) * (start_j - i) * inter_frame_factor
-          + prev_forward_cost[start_j];
-      int32 best_j = start_j;
-
-      for (int32 j = start_j + 1; j < num_states; j++) {
-        BaseFloat this_cost = (j - i) * (j - i) * inter_frame_factor
-            + prev_forward_cost[j];
-        if (this_cost < best_cost) {
-          best_cost = this_cost;
-          best_j = j;
-        } else {  // as soon as the costs stop improving, we stop searching.
-          break;  // this is a loose lower bound we're getting.
-        }
-      }
-      state_info_[i].backpointer = best_j;
-      this_forward_cost[i] = best_cost;
-      bounds[i].first = best_j;  // this is now a lower bound on the
-                                 // backpointer.
-      bounds[i].second = num_states - 1;  // we have no meaningful upper bound
-                                          // yet.
-      last_backpointer = best_j;
-    }
-
-    // We iterate, progressively refining the upper and lower bounds until they
-    // meet and we know that the resulting backtraces are optimal.  Each
-    // iteration takes time linear in num_states.  We won't normally iterate as
-    // far as num_states; normally we only do two iterations; when printing out
-    // the number of iterations, it's rarely more than that (once I saw seven
-    // iterations).  Anyway, this part of the computation does not dominate.
-    for (int32 iter = 0; iter < num_states; iter++) {
-      bool changed = false;
-      if (iter % 2 == 0) {  // go backwards through the states
-        last_backpointer = num_states - 1;
-        for (int32 i = num_states - 1; i >= 0; i--) {
-          int32 lower_bound = bounds[i].first,
-              upper_bound = std::min(last_backpointer, bounds[i].second);
-          if (upper_bound == lower_bound) {
-            last_backpointer = lower_bound;
-            continue;
-          }
-          BaseFloat best_cost = this_forward_cost[i];
-          int32 best_j = state_info_[i].backpointer, initial_best_j = best_j;
-
-          if (best_j == upper_bound) {
-            // if best_j already equals upper bound, don't bother tightening the
-            // upper bound, we'll tighten the lower bound when the time comes.
-            last_backpointer = best_j;
-            continue;
-          }
-          // Below, we have j > lower_bound + 1 because we know we've already
-          // evaluated lower_bound and lower_bound + 1 [via knowledge of
-          // this algorithm.]
-          for (int32 j = upper_bound; j > lower_bound + 1; j--) {
-            BaseFloat this_cost = (j - i) * (j - i) * inter_frame_factor
-                + prev_forward_cost[j];
-            if (this_cost < best_cost) {
-              best_cost = this_cost;
-              best_j = j;
-            } else {  // as soon as the costs stop improving, we stop searching,
-              // unless the best j is still lower than j, in which case
-              // we obviously need to keep moving.
-              if (best_j > j)
-                break;  // this is a loose lower bound we're getting.
-            }
-          }
-          // our "best_j" is now an upper bound on the backpointer.
-          bounds[i].second = best_j;
-          if (best_j != initial_best_j) {
-            this_forward_cost[i] = best_cost;
-            state_info_[i].backpointer = best_j;
-            changed = true;
-          }
-          last_backpointer = best_j;
-        }
-      } else {  // go forwards through the states.
-        last_backpointer = 0;
-        for (int32 i = 0; i < num_states; i++) {
-          int32 lower_bound = std::max(last_backpointer, bounds[i].first),
-              upper_bound = bounds[i].second;
-          if (upper_bound == lower_bound) {
-            last_backpointer = lower_bound;
-            continue;
-          }
-          BaseFloat best_cost = this_forward_cost[i];
-          int32 best_j = state_info_[i].backpointer, initial_best_j = best_j;
-
-          if (best_j == lower_bound) {
-            // if best_j already equals lower bound, we don't bother tightening
-            // the lower bound, we'll tighten the upper bound when the time
-            // comes.
-            last_backpointer = best_j;
-            continue;
-          }
-          // Below, we have j < upper_bound because we know we've already
-          // evaluated that point.
-          for (int32 j = lower_bound; j < upper_bound - 1; j++) {
-            BaseFloat this_cost = (j - i) * (j - i) * inter_frame_factor
-                + prev_forward_cost[j];
-            if (this_cost < best_cost) {
-              best_cost = this_cost;
-              best_j = j;
-            } else {  // as soon as the costs stop improving, we stop searching,
-              // unless the best j is still higher than j, in which case
-              // we obviously need to keep moving.
-              if (best_j < j)
-                break;  // this is a loose lower bound we're getting.
-            }
-          }
-          // our "best_j" is now a lower bound on the backpointer.
-          bounds[i].first = best_j;
-          if (best_j != initial_best_j) {
-            this_forward_cost[i] = best_cost;
-            state_info_[i].backpointer = best_j;
-            changed = true;
-          }
-          last_backpointer = best_j;
-        }
-      }
-      if (!changed)
-        break;
-    }
-  }
-  // The next statement is needed due to RecomputeBacktraces: we have to
-  // invalidate the previously computed best-state info.
-  cur_best_state_ = -1;  
-  this_forward_cost_vec->AddVec(1.0, local_cost);
-}
-
-void PitchFrameInfo::SetBestState(
-    int32 best_state,
-    std::vector<std::pair<int32, BaseFloat> > &lag_nccf) {
-
-  // This function would naturally be recursive, but we have coded this to avoid
-  // recursion, which would otherwise eat up the stack.  Think of it as a static
-  // member function, except we do use "this" right at the beginning.
-
-  std::vector<std::pair<int32, BaseFloat> >::reverse_iterator iter = lag_nccf.rbegin();
-
-  PitchFrameInfo *this_info = this;  // it will change in the loop.
-  while (this_info != NULL) {
-    PitchFrameInfo *prev_info = this_info->prev_info_;
-    if (best_state == this_info->cur_best_state_)
-      return;  // no change
-    if (prev_info != NULL)  // don't write anything for frame -1.
-      iter->first = best_state;
-    size_t state_info_index = best_state - this_info->state_offset_;
-    KALDI_ASSERT(state_info_index < this_info->state_info_.size());
-    this_info->cur_best_state_ = best_state;
-    best_state = this_info->state_info_[state_info_index].backpointer;
-    if (prev_info != NULL)  // don't write anything for frame -1.
-      iter->second = this_info->state_info_[state_info_index].pov_nccf;
-    this_info = prev_info;
-    if (this_info != NULL) ++iter;
-  }
-}
-
-int32 PitchFrameInfo::ComputeLatency(int32 max_latency) {
-  if (max_latency <= 0) return 0;
-
-  int32 latency = 0;
-
-  // This function would naturally be recursive, but we have coded this to avoid
-  // recursion, which would otherwise eat up the stack.  Think of it as a static
-  // member function, except we do use "this" right at the beginning.
-  // This function is called only on the most recent PitchFrameInfo object.
-  int32 num_states = state_info_.size();
-  int32 min_living_state = 0, max_living_state = num_states - 1;
-  PitchFrameInfo *this_info = this;  // it will change in the loop.
-
-
-  for (; this_info != NULL && latency < max_latency;) {
-    int32 offset = this_info->state_offset_;
-    KALDI_ASSERT(min_living_state >= offset &&
-                 max_living_state - offset < this_info->state_info_.size());
-    min_living_state =
-        this_info->state_info_[min_living_state - offset].backpointer;
-    max_living_state =
-        this_info->state_info_[max_living_state - offset].backpointer;
-    if (min_living_state == max_living_state) {
-      return latency;
-    }
-    this_info = this_info->prev_info_;
-    if (this_info != NULL)  // avoid incrementing latency for frame -1,
-      latency++;            // as it's not a real frame.
-  }
-  return latency;
-}
-
-void PitchFrameInfo::Cleanup(PitchFrameInfo *prev_frame) {
-  KALDI_ERR << "Cleanup not implemented.";
-}
-
-
-// struct NccfInfo is used to cache certain quantities that we need for online
-// operation, for the first "recompute_frame" frames of the file (e.g. 300);
-// after that many frames, or after the user calls InputFinished(), we redo the
-// initial backtraces, as we'll then have a better estimate of the average signal
-// energy.
-struct NccfInfo {
-
-  Vector<BaseFloat> nccf_pitch_resampled;  // resampled nccf_pitch
-  BaseFloat avg_norm_prod; // average value of e1 * e2.
-  BaseFloat mean_square_energy;  // mean_square energy we used when computing the
-                                 // original ballast term for
-                                 // "nccf_pitch_resampled".
-  
-  NccfInfo(BaseFloat avg_norm_prod,
-           BaseFloat mean_square_energy):
-      avg_norm_prod(avg_norm_prod),
-      mean_square_energy(mean_square_energy) { }
-};
-
-
-
-// We could inherit from OnlineBaseFeature as we have the same interface,
-// but this will unnecessary force a lot of our functions to be virtual.
-class OnlinePitchFeatureImpl {
- public:
-  explicit OnlinePitchFeatureImpl(const PitchExtractionOptions &opts);
-
-  int32 Dim() const { return 2; }
-  
-  BaseFloat FrameShiftInSeconds() const;
-
-  int32 NumFramesReady() const;
-
-  bool IsLastFrame(int32 frame) const;
-
-  void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  void AcceptWaveform(BaseFloat sampling_rate,
-                      const VectorBase<BaseFloat> &waveform);
-
-  void InputFinished();
-
-  ~OnlinePitchFeatureImpl();
-
-
-  // Copy-constructor, can be used to obtain a new copy of this object,
-  // any state from this utterance.
-  OnlinePitchFeatureImpl(const OnlinePitchFeatureImpl &other);
-
- private:
-
-  /// This function works out from the signal how many frames are currently
-  /// available to process (this is called from inside AcceptWaveform()).
-  /// Note: the number of frames differs slightly from the number the
-  /// old pitch code gave.
-  /// Note: the number this returns depends on whether input_finished_ == true;
-  /// if it is, it will "force out" a final frame or two.
-  int32 NumFramesAvailable(int64 num_downsampled_samples, bool snip_edges) const;
-  
-  /// This function extracts from the signal the samples numbered from
-  /// "sample_index" (numbered in the full downsampled signal, not just this
-  /// part), and of length equal to window->Dim().  It uses the data members
-  /// downsampled_samples_discarded_ and downsampled_signal_remainder_, as well
-  /// as the more recent part of the downsampled wave "downsampled_wave_part"
-  /// which is provided.
-  ///
-  /// @param downsampled_wave_part  One chunk of the downsampled wave,
-  ///                      starting from sample-index downsampled_samples_discarded_.
-  /// @param sample_index  The desired starting sample index (measured from
-  ///                      the start of the whole signal, not just this part).
-  /// @param window  The part of the signal is output to here.
-  void ExtractFrame(const VectorBase<BaseFloat> &downsampled_wave_part,
-                    int64 frame_index,
-                    VectorBase<BaseFloat> *window);
-
-
-  /// This function is called after we reach frame "recompute_frame", or when
-  /// InputFinished() is called, whichever comes sooner.  It recomputes the
-  /// backtraces for frames zero through recompute_frame, if needed because the
-  /// average energy of the signal has changed, affecting the nccf ballast term.
-  /// It works out the average signal energy from
-  /// downsampled_samples_processed_, signal_sum_ and signal_sumsq_ (which, if
-  /// you see the calling code, might include more frames than just
-  /// "recompute_frame", it might include up to the end of the current chunk).
-  void RecomputeBacktraces();
-
-  
-  /// This function updates downsampled_signal_remainder_,
-  /// downsampled_samples_processed_, signal_sum_ and signal_sumsq_; it's called
-  /// from AcceptWaveform().
-  void UpdateRemainder(const VectorBase<BaseFloat> &downsampled_wave_part);
-
-
-  // The following variables don't change throughout the lifetime
-  // of this object.
-  PitchExtractionOptions opts_;
-
-  // the first lag of the downsampled signal at which we measure NCCF
-  int32 nccf_first_lag_;
-  // the last lag of the downsampled signal at which we measure NCCF
-  int32 nccf_last_lag_;
-
-  // The log-spaced lags at which we will resample the NCCF
-  Vector<BaseFloat> lags_;
-
-  // This object is used to resample from evenly spaced to log-evenly-spaced
-  // nccf values.  It's a pointer for convenience of initialization, so we don't
-  // have to use the initializer from the constructor.
-  ArbitraryResample *nccf_resampler_;
-
-  // The following objects may change during the lifetime of this object.
-
-  // This object is used to resample the signal.
-  LinearResample *signal_resampler_;
-
-  // frame_info_ is indexed by [frame-index + 1].  frame_info_[0] is an object
-  // that corresponds to frame -1, which is not a real frame.
-  std::vector<PitchFrameInfo*> frame_info_;
-
-
-  // nccf_info_ is indexed by frame-index, from frame 0 to at most
-  // opts_.recompute_frame - 1.  It contains some information we'll
-  // need to recompute the tracebacks after getting a better estimate
-  // of the average energy of the signal.
-  std::vector<NccfInfo*> nccf_info_;  
-
-  // Current number of frames which we can't output because Viterbi has not
-  // converged for them, or opts_.max_frames_latency if we have reached that
-  // limit.
-  int32 frames_latency_;
-
-  // The forward-cost at the current frame (the last frame in frame_info_);
-  // this has the same dimension as lags_.  We normalize each time so
-  // the lowest cost is zero, for numerical accuracy and so we can use float.
-  Vector<BaseFloat> forward_cost_;
-
-  // stores the constant part of forward_cost_.
-  double forward_cost_remainder_;
-
-  // The resampled-lag index and the NCCF (as computed for POV, without ballast
-  // term) for each frame, as determined by Viterbi traceback from the best
-  // final state.
-  std::vector<std::pair<int32, BaseFloat> > lag_nccf_;
-
-  bool input_finished_;
-
-  /// sum-squared of previously processed parts of signal; used to get NCCF
-  /// ballast term.  Denominator is downsampled_samples_processed_.
-  double signal_sumsq_;
-
-  /// sum of previously processed parts of signal; used to do mean-subtraction
-  /// when getting sum-squared, along with signal_sumsq_.
-  double signal_sum_;
-
-  /// downsampled_samples_processed is the number of samples (after
-  /// downsampling) that we got in previous calls to AcceptWaveform().
-  int64 downsampled_samples_processed_;
-  /// This is a small remainder of the previous downsampled signal;
-  /// it's used by ExtractFrame for frames near the boundary of two
-  /// waveforms supplied to AcceptWaveform().
-  Vector<BaseFloat> downsampled_signal_remainder_;
-};
-
-
-OnlinePitchFeatureImpl::OnlinePitchFeatureImpl(
-    const PitchExtractionOptions &opts):
-    opts_(opts), forward_cost_remainder_(0.0), input_finished_(false),
-    signal_sumsq_(0.0), signal_sum_(0.0), downsampled_samples_processed_(0) {
-  signal_resampler_ = new LinearResample(opts.samp_freq, opts.resample_freq,
-                                         opts.lowpass_cutoff,
-                                         opts.lowpass_filter_width);
-
-  double outer_min_lag = 1.0 / opts.max_f0 -
-      (opts.upsample_filter_width/(2.0 * opts.resample_freq));
-  double outer_max_lag = 1.0 / opts.min_f0 +
-      (opts.upsample_filter_width/(2.0 * opts.resample_freq));
-  nccf_first_lag_ = ceil(opts.resample_freq * outer_min_lag);
-  nccf_last_lag_ = floor(opts.resample_freq * outer_max_lag);
-
-  frames_latency_ = 0;  // will be set in AcceptWaveform()
-
-  // Choose the lags at which we resample the NCCF.
-  SelectLags(opts, &lags_);
-
-  // upsample_cutoff is the filter cutoff for upsampling the NCCF, which is the
-  // Nyquist of the resampling frequency.  The NCCF is (almost completely)
-  // bandlimited to around "lowpass_cutoff" (1000 by default), and when the
-  // spectrum of this bandlimited signal is convolved with the spectrum of an
-  // impulse train with frequency "resample_freq", which are separated by 4kHz,
-  // we get energy at -5000,-3000, -1000...1000, 3000..5000, etc.  Filtering at
-  // half the Nyquist (2000 by default) is sufficient to get only the first
-  // repetition.
-  BaseFloat upsample_cutoff = opts.resample_freq * 0.5;
-
-
-  Vector<BaseFloat> lags_offset(lags_);
-  // lags_offset equals lags_ (which are the log-spaced lag values we want to
-  // measure the NCCF at) with nccf_first_lag_ / opts.resample_freq subtracted
-  // from each element, so we can treat the measured NCCF values as as starting
-  // from sample zero in a signal that starts at the point start /
-  // opts.resample_freq.  This is necessary because the ArbitraryResample code
-  // assumes that the input signal starts from sample zero.
-  lags_offset.Add(-nccf_first_lag_ / opts.resample_freq);
-
-  int32 num_measured_lags = nccf_last_lag_ + 1 - nccf_first_lag_;
-
-  nccf_resampler_ = new ArbitraryResample(num_measured_lags, opts.resample_freq,
-                                          upsample_cutoff, lags_offset,
-                                          opts.upsample_filter_width);
-
-  // add a PitchInfo object for frame -1 (not a real frame).
-  frame_info_.push_back(new PitchFrameInfo(lags_.Dim()));
-  // zeroes forward_cost_; this is what we want for the fake frame -1.
-  forward_cost_.Resize(lags_.Dim());
-}
-
-
-int32 OnlinePitchFeatureImpl::NumFramesAvailable(
-    int64 num_downsampled_samples, bool snip_edges) const {
-  int32 frame_shift = opts_.NccfWindowShift(),
-      frame_length = opts_.NccfWindowSize();
-  // Use the "full frame length" to compute the number
-  // of frames only if the input is not finished.
-  if (!input_finished_)
-    frame_length += nccf_last_lag_;
-  if (num_downsampled_samples < frame_length) return 0;
-  else
-    if (input_finished_ && !snip_edges) {
-      return (int32)(num_downsampled_samples * 1.0f / frame_shift + 0.5f);
-    }
-    else
-      return ((num_downsampled_samples - frame_length) / frame_shift) + 1;
-}
-
-void OnlinePitchFeatureImpl::UpdateRemainder(
-    const VectorBase<BaseFloat> &downsampled_wave_part) {
-  // frame_info_ has an extra element at frame-1, so subtract
-  // one from the length.
-  int64 num_frames = static_cast<int64>(frame_info_.size()) - 1,
-      next_frame = num_frames,
-      frame_shift = opts_.NccfWindowShift(),
-      next_frame_sample = frame_shift * next_frame;
-
-  signal_sumsq_ += VecVec(downsampled_wave_part, downsampled_wave_part);
-  signal_sum_ += downsampled_wave_part.Sum();
-
-  // next_frame_sample is the first sample index we'll need for the
-  // next frame.
-  int64 next_downsampled_samples_processed =
-      downsampled_samples_processed_ + downsampled_wave_part.Dim();
-
-  if (next_frame_sample > next_downsampled_samples_processed) {
-    // this could only happen in the weird situation that the full frame length
-    // is less than the frame shift.
-    int32 full_frame_length = opts_.NccfWindowSize() + nccf_last_lag_;
-    KALDI_ASSERT(full_frame_length < frame_shift && "Code error");
-    downsampled_signal_remainder_.Resize(0);
-  } else {
-    Vector<BaseFloat> new_remainder(next_downsampled_samples_processed -
-                                    next_frame_sample);
-    // note: next_frame_sample is the index into the entire signal, of
-    // new_remainder(0).
-    // i is the absolute index of the signal.
-    for (int64 i = next_frame_sample;
-         i < next_downsampled_samples_processed; i++) {
-      if (i >= downsampled_samples_processed_) {  // in current signal.
-        new_remainder(i - next_frame_sample) =
-            downsampled_wave_part(i - downsampled_samples_processed_);
-      } else {  // in old remainder; only reach here if waveform supplied is
-        new_remainder(i - next_frame_sample) =                      //  tiny.
-            downsampled_signal_remainder_(i - downsampled_samples_processed_ +
-                                          downsampled_signal_remainder_.Dim());
-      }
-    }
-    downsampled_signal_remainder_.Swap(&new_remainder);
-  }
-  downsampled_samples_processed_ = next_downsampled_samples_processed;
-}
-
-void OnlinePitchFeatureImpl::ExtractFrame(
-    const VectorBase<BaseFloat> &downsampled_wave_part,
-    int64 sample_index,
-    VectorBase<BaseFloat> *window) {
-  int32 full_frame_length = window->Dim();
-  int32 offset = static_cast<int32>(sample_index -
-                                    downsampled_samples_processed_);
-
-  if (offset + full_frame_length > downsampled_wave_part.Dim()) {
-    // Requested frame is past end of the signal.  This should only happen if
-    // input_finished_ == true, when we're flushing out the last couple of
-    // frames of signal.  In this case we pad with zeros.
-    KALDI_ASSERT(input_finished_);
-    int32 new_full_frame_length = downsampled_wave_part.Dim() - offset;
-    KALDI_ASSERT(new_full_frame_length > 0);
-    window->SetZero();
-    SubVector<BaseFloat> sub_window(*window, 0, new_full_frame_length);
-    ExtractFrame(downsampled_wave_part, sample_index, &sub_window);
-    return;
-  }
-  
-  // "offset" is the offset of the start of the frame, into this
-  // signal.
-  if (offset >= 0) {
-    // frame is full inside the new part of the signal.
-    window->CopyFromVec(downsampled_wave_part.Range(offset, full_frame_length));
-  } else {
-    // frame is partly in the remainder and partly in the new part.
-    int32 remainder_offset = downsampled_signal_remainder_.Dim() + offset;
-    KALDI_ASSERT(remainder_offset >= 0);  // or we didn't keep enough remainder.
-    KALDI_ASSERT(offset + full_frame_length > 0);  // or we should have
-                                                   // processed this frame last
-                                                   // time.
-
-    int32 old_length = -offset, new_length = offset + full_frame_length;
-    window->Range(0, old_length).CopyFromVec(
-        downsampled_signal_remainder_.Range(remainder_offset, old_length));
-    window->Range(old_length, new_length).CopyFromVec(
-        downsampled_wave_part.Range(0, new_length));
-  }
-  if (opts_.preemph_coeff != 0.0) {
-    BaseFloat preemph_coeff = opts_.preemph_coeff;
-    for (int32 i = window->Dim() - 1; i > 0; i--)
-      (*window)(i) -= preemph_coeff * (*window)(i-1);
-    (*window)(0) *= (1.0 - preemph_coeff);
-  }
-}
-
-bool OnlinePitchFeatureImpl::IsLastFrame(int32 frame) const {
-  int32 T = NumFramesReady();
-  KALDI_ASSERT(frame < T);
-  return (input_finished_ && frame + 1 == T);
-}
-
-BaseFloat OnlinePitchFeatureImpl::FrameShiftInSeconds() const {
-  return opts_.frame_shift_ms * 1.0e-03;
-}
-
-int32 OnlinePitchFeatureImpl::NumFramesReady() const {
-  int32 num_frames = lag_nccf_.size(),
-      latency = frames_latency_;
-  KALDI_ASSERT(latency <= num_frames);
-  return num_frames - latency;
-}
-
-
-void OnlinePitchFeatureImpl::GetFrame(int32 frame,
-                                      VectorBase<BaseFloat> *feat) {
-  KALDI_ASSERT(frame < NumFramesReady() && feat->Dim() == 2);
-  (*feat)(0) = lag_nccf_[frame].second;
-  (*feat)(1) = 1.0 / lags_(lag_nccf_[frame].first);
-}
-
-void OnlinePitchFeatureImpl::InputFinished() {
-  input_finished_ = true;
-  // Process an empty waveform; this has an effect because
-  // after setting input_finished_ to true, NumFramesAvailable()
-  // will return a slightly larger number.
-  AcceptWaveform(opts_.samp_freq, Vector<BaseFloat>());
-  int32 num_frames = static_cast<size_t>(frame_info_.size() - 1);
-  if (num_frames < opts_.recompute_frame && !opts_.nccf_ballast_online)
-    RecomputeBacktraces();
-  frames_latency_ = 0;
-  KALDI_VLOG(3) << "Pitch-tracking Viterbi cost is "
-                << (forward_cost_remainder_ / num_frames)
-                << " per frame, over " << num_frames << " frames.";
-}
-
-// see comment with declaration.  This is only relevant for online
-// operation (it gets called for non-online mode, but is a no-op).
-void OnlinePitchFeatureImpl::RecomputeBacktraces() {
-  KALDI_ASSERT(!opts_.nccf_ballast_online);
-  int32 num_frames = static_cast<int32>(frame_info_.size()) - 1;
-  
-  // The assertion reflects how we believe this function will be called.
-  KALDI_ASSERT(num_frames <= opts_.recompute_frame);
-  KALDI_ASSERT(nccf_info_.size() == static_cast<size_t>(num_frames));
-  if (num_frames == 0)
-    return;
-  double num_samp = downsampled_samples_processed_, sum = signal_sum_,
-      sumsq = signal_sumsq_, mean = sum / num_samp;
-  BaseFloat mean_square = sumsq / num_samp - mean * mean;
-  
-  bool must_recompute = false;
-  BaseFloat threshold = 0.01;
-  for (int32 frame = 0; frame < num_frames; frame++)
-    if (!ApproxEqual(nccf_info_[frame]->mean_square_energy,
-                     mean_square, threshold))
-      must_recompute = true;
-  
-  if (!must_recompute) {
-    // Nothing to do.  We'll reach here, for instance, if everything was in one
-    // chunk and opts_.nccf_ballast_online == false.  This is the case for
-    // offline processing.
-    for (size_t i = 0; i < nccf_info_.size(); i++)
-      delete nccf_info_[i];
-    nccf_info_.clear();
-    return;
-  }
-  
-  int32 num_states = forward_cost_.Dim(),
-      basic_frame_length = opts_.NccfWindowSize();
-  
-  BaseFloat new_nccf_ballast = pow(mean_square * basic_frame_length, 2) *
-      opts_.nccf_ballast;
-  
-  double forward_cost_remainder = 0.0;
-  Vector<BaseFloat> forward_cost(num_states),  // start off at zero.
-      next_forward_cost(forward_cost);
-  std::vector<std::pair<int32, int32 > > index_info;
-  
-  for (int32 frame = 0; frame < num_frames; frame++) {
-    NccfInfo &nccf_info = *nccf_info_[frame];
-    BaseFloat old_mean_square = nccf_info_[frame]->mean_square_energy,
-        avg_norm_prod = nccf_info_[frame]->avg_norm_prod,
-        old_nccf_ballast = pow(old_mean_square * basic_frame_length, 2) *
-            opts_.nccf_ballast,
-        nccf_scale = pow((old_nccf_ballast + avg_norm_prod) /
-                         (new_nccf_ballast + avg_norm_prod),
-                         static_cast<BaseFloat>(0.5));
-    // The "nccf_scale" is an estimate of the scaling factor by which the NCCF
-    // would change on this frame, on average, by changing the ballast term from
-    // "old_nccf_ballast" to "new_nccf_ballast".  It's not exact because the
-    // "avg_norm_prod" is just an average of the product e1 * e2 of frame
-    // energies of the (frame, shifted-frame), but these won't change that much
-    // within a frame, and even if they do, the inaccuracy of the scaled NCCF
-    // will still be very small if the ballast term didn't change much, or if
-    // it's much larger or smaller than e1*e2.  By doing it as a simple scaling,
-    // we save the overhead of the NCCF resampling, which is a considerable part
-    // of the whole computation.
-    nccf_info.nccf_pitch_resampled.Scale(nccf_scale);
-    
-    frame_info_[frame + 1]->ComputeBacktraces(
-        opts_, nccf_info.nccf_pitch_resampled, lags_,
-        forward_cost, &index_info, &next_forward_cost);
-
-    forward_cost.Swap(&next_forward_cost);
-    BaseFloat remainder = forward_cost.Min();
-    forward_cost_remainder += remainder;
-    forward_cost.Add(-remainder);
-  }
-  KALDI_VLOG(3) << "Forward-cost per frame changed from "
-                << (forward_cost_remainder_ / num_frames) << " to "
-                << (forward_cost_remainder / num_frames);
-
-  forward_cost_remainder_ = forward_cost_remainder;
-  forward_cost_.Swap(&forward_cost);
-  
-  int32 best_final_state;
-  forward_cost_.Min(&best_final_state);
-  
-  if (lag_nccf_.size() != static_cast<size_t>(num_frames))
-    lag_nccf_.resize(num_frames);
-  
-  frame_info_.back()->SetBestState(best_final_state, lag_nccf_);
-  frames_latency_ =
-      frame_info_.back()->ComputeLatency(opts_.max_frames_latency);
-  for (size_t i = 0; i < nccf_info_.size(); i++)
-    delete nccf_info_[i];
-  nccf_info_.clear();  
-}
-
-OnlinePitchFeatureImpl::~OnlinePitchFeatureImpl() {
-  delete nccf_resampler_;
-  delete signal_resampler_;
-  for (size_t i = 0; i < frame_info_.size(); i++)
-    delete frame_info_[i];
-  for (size_t i = 0; i < nccf_info_.size(); i++)
-    delete nccf_info_[i];
-}
-
-void OnlinePitchFeatureImpl::AcceptWaveform(
-    BaseFloat sampling_rate,
-    const VectorBase<BaseFloat> &wave) {
-  // flush out the last few samples of input waveform only if input_finished_ ==
-  // true.
-  const bool flush = input_finished_;
-  
-  Vector<BaseFloat> downsampled_wave;
-  signal_resampler_->Resample(wave, flush, &downsampled_wave);
-
-  // these variables will be used to compute the root-mean-square value of the
-  // signal for the ballast term.
-  double cur_sumsq = signal_sumsq_, cur_sum = signal_sum_;
-  int64 cur_num_samp = downsampled_samples_processed_,
-      prev_frame_end_sample = 0;
-  if (!opts_.nccf_ballast_online) {
-    cur_sumsq += VecVec(downsampled_wave, downsampled_wave);
-    cur_sum += downsampled_wave.Sum();
-    cur_num_samp += downsampled_wave.Dim();
-  }
-
-  // end_frame is the total number of frames we can now process, including
-  // previously processed ones.
-  int32 end_frame = NumFramesAvailable(
-      downsampled_samples_processed_ + downsampled_wave.Dim(), opts_.snip_edges);
-  // "start_frame" is the first frame-index we process
-  int32 start_frame = frame_info_.size() - 1,
-      num_new_frames = end_frame - start_frame;
-
-  if (num_new_frames == 0) {
-    UpdateRemainder(downsampled_wave);
-    return;
-    // continuing to the rest of the code would generate
-    // an error when sizing matrices with zero rows, and
-    // anyway is a waste of time.
-  }
-
-  int32 num_measured_lags = nccf_last_lag_ + 1 - nccf_first_lag_,
-      num_resampled_lags = lags_.Dim(),
-      frame_shift = opts_.NccfWindowShift(),
-      basic_frame_length = opts_.NccfWindowSize(),
-      full_frame_length = basic_frame_length + nccf_last_lag_;
-
-  Vector<BaseFloat> window(full_frame_length),
-      inner_prod(num_measured_lags),
-      norm_prod(num_measured_lags);
-  Matrix<BaseFloat> nccf_pitch(num_new_frames, num_measured_lags),
-      nccf_pov(num_new_frames, num_measured_lags);
-
-  Vector<BaseFloat> cur_forward_cost(num_resampled_lags);
-
-
-  // Because the resampling of the NCCF is more efficient when grouped together,
-  // we first compute the NCCF for all frames, then resample as a matrix, then
-  // do the Viterbi [that happens inside the constructor of PitchFrameInfo].
-
-  for (int32 frame = start_frame; frame < end_frame; frame++) {
-    // start_sample is index into the whole wave, not just this part.
-    int64 start_sample = static_cast<int64>(frame) * frame_shift;
-    ExtractFrame(downsampled_wave, start_sample, &window);
-    if (opts_.nccf_ballast_online) {
-      // use only up to end of current frame to compute root-mean-square value.
-      // end_sample will be the sample-index into "downsampled_wave", so
-      // not really comparable to start_sample.
-      int64 end_sample = start_sample + full_frame_length -
-          downsampled_samples_processed_;
-      KALDI_ASSERT(end_sample > 0);  // or should have processed this frame last
-                                     // time.  Note: end_sample is one past last
-                                     // sample.
-      if (end_sample > downsampled_wave.Dim()) {
-        KALDI_ASSERT(input_finished_);
-        end_sample = downsampled_wave.Dim();
-      }
-      SubVector<BaseFloat> new_part(downsampled_wave, prev_frame_end_sample,
-                                    end_sample - prev_frame_end_sample);
-      cur_num_samp += new_part.Dim();
-      cur_sumsq += VecVec(new_part, new_part);
-      cur_sum += new_part.Sum();
-      prev_frame_end_sample = end_sample;
-    }
-    double mean_square = cur_sumsq / cur_num_samp -
-        pow(cur_sum / cur_num_samp, 2.0);
-
-    ComputeCorrelation(window, nccf_first_lag_, nccf_last_lag_,
-                       basic_frame_length, &inner_prod, &norm_prod);
-    double nccf_ballast_pov = 0.0,
-        nccf_ballast_pitch = pow(mean_square * basic_frame_length, 2) *
-             opts_.nccf_ballast,
-        avg_norm_prod = norm_prod.Sum() / norm_prod.Dim();
-    SubVector<BaseFloat> nccf_pitch_row(nccf_pitch, frame - start_frame);
-    ComputeNccf(inner_prod, norm_prod, nccf_ballast_pitch,
-                &nccf_pitch_row);
-    SubVector<BaseFloat> nccf_pov_row(nccf_pov, frame - start_frame);
-    ComputeNccf(inner_prod, norm_prod, nccf_ballast_pov,
-                &nccf_pov_row);
-    if (frame < opts_.recompute_frame)
-      nccf_info_.push_back(new NccfInfo(avg_norm_prod, mean_square));
-  }
-
-  Matrix<BaseFloat> nccf_pitch_resampled(num_new_frames, num_resampled_lags);
-  nccf_resampler_->Resample(nccf_pitch, &nccf_pitch_resampled);
-  nccf_pitch.Resize(0, 0);  // no longer needed.
-  Matrix<BaseFloat> nccf_pov_resampled(num_new_frames, num_resampled_lags);
-  nccf_resampler_->Resample(nccf_pov, &nccf_pov_resampled);
-  nccf_pov.Resize(0, 0);  // no longer needed.
-
-  // We've finished dealing with the waveform so we can call UpdateRemainder
-  // now; we need to call it before we possibly call RecomputeBacktraces()
-  // below, which is why we don't do it at the very end.
-  UpdateRemainder(downsampled_wave);
-
-  std::vector<std::pair<int32, int32 > > index_info;
-  
-  for (int32 frame = start_frame; frame < end_frame; frame++) {
-    int32 frame_idx = frame - start_frame;
-    PitchFrameInfo *prev_info = frame_info_.back(),
-        *cur_info = new PitchFrameInfo(prev_info);
-    cur_info->SetNccfPov(nccf_pov_resampled.Row(frame_idx));
-    cur_info->ComputeBacktraces(opts_, nccf_pitch_resampled.Row(frame_idx),
-                                lags_, forward_cost_, &index_info,
-                                &cur_forward_cost);
-    forward_cost_.Swap(&cur_forward_cost);
-    // Renormalize forward_cost so smallest element is zero.
-    BaseFloat remainder = forward_cost_.Min();
-    forward_cost_remainder_ += remainder;
-    forward_cost_.Add(-remainder);
-    frame_info_.push_back(cur_info);
-    if (frame < opts_.recompute_frame)
-      nccf_info_[frame]->nccf_pitch_resampled =
-          nccf_pitch_resampled.Row(frame_idx);
-    if (frame == opts_.recompute_frame - 1 && !opts_.nccf_ballast_online)
-      RecomputeBacktraces();
-  }
-  
-  // Trace back the best-path.
-  int32 best_final_state;
-  forward_cost_.Min(&best_final_state);
-  lag_nccf_.resize(frame_info_.size() - 1);  // will keep any existing data.
-  frame_info_.back()->SetBestState(best_final_state, lag_nccf_);
-  frames_latency_ =
-      frame_info_.back()->ComputeLatency(opts_.max_frames_latency);
-  KALDI_VLOG(4) << "Latency is " << frames_latency_;
-}
-
-
-
-// Some functions that forward from OnlinePitchFeature to
-// OnlinePitchFeatureImpl.
-int32 OnlinePitchFeature::NumFramesReady() const {
-  return impl_->NumFramesReady();
-}
-
-OnlinePitchFeature::OnlinePitchFeature(const PitchExtractionOptions &opts)
-    :impl_(new OnlinePitchFeatureImpl(opts)) { }
-
-bool OnlinePitchFeature::IsLastFrame(int32 frame) const {
-  return impl_->IsLastFrame(frame);
-}
-
-BaseFloat OnlinePitchFeature::FrameShiftInSeconds() const {
-  return impl_->FrameShiftInSeconds();
-}
-
-void OnlinePitchFeature::GetFrame(int32 frame, VectorBase<BaseFloat> *feat) {
-  impl_->GetFrame(frame, feat);
-}
-
-void OnlinePitchFeature::AcceptWaveform(
-    BaseFloat sampling_rate,
-    const VectorBase<BaseFloat> &waveform) {
-  impl_->AcceptWaveform(sampling_rate, waveform);
-}
-
-void OnlinePitchFeature::InputFinished() {
-  impl_->InputFinished();
-}
-
-OnlinePitchFeature::~OnlinePitchFeature() {
-  delete impl_;
-}
-
-
-/**
-   This function is called from ComputeKaldiPitch when the user
-   specifies opts.simulate_first_pass_online == true.  It gives
-   the "first-pass" version of the features, which you would get
-   on the first decoding pass in an online setting.  These may
-   differ slightly from the final features due to both the
-   way the Viterbi traceback works (this is affected by
-   opts.max_frames_latency), and the online way we compute
-   the average signal energy.
-*/
-void ComputeKaldiPitchFirstPass(
-    const PitchExtractionOptions &opts,
-    const VectorBase<BaseFloat> &wave,
-    Matrix<BaseFloat> *output) {
-
-  int32 cur_rows = 100;
-  Matrix<BaseFloat> feats(cur_rows, 2);
-  
-  OnlinePitchFeature pitch_extractor(opts);
-  KALDI_ASSERT(opts.frames_per_chunk > 0 &&
-               "--simulate-first-pass-online option does not make sense "
-               "unless you specify --frames-per-chunk");
-
-  int32 cur_offset = 0, cur_frame = 0, samp_per_chunk =
-      opts.frames_per_chunk * opts.samp_freq * 1.0e-03 * opts.frame_shift_ms;
-  
-  while (cur_offset < wave.Dim()) {
-    int32 num_samp = std::min(samp_per_chunk, wave.Dim() - cur_offset);
-    SubVector<BaseFloat> wave_chunk(wave, cur_offset, num_samp);
-    pitch_extractor.AcceptWaveform(opts.samp_freq, wave_chunk);
-    cur_offset += num_samp;
-    if (cur_offset == wave.Dim())
-      pitch_extractor.InputFinished();
-    // Get each frame as soon as it is ready.
-    for (; cur_frame < pitch_extractor.NumFramesReady(); cur_frame++) {
-      if (cur_frame >= cur_rows) {
-        cur_rows *= 2;
-        feats.Resize(cur_rows, 2, kCopyData);
-      }
-      SubVector<BaseFloat> row(feats, cur_frame);
-      pitch_extractor.GetFrame(cur_frame, &row);
-    }
-  }
-  if (cur_frame  == 0) {
-    KALDI_WARN << "No features output since wave file too short";
-    output->Resize(0, 0);
-  } else {
-    *output = feats.RowRange(0, cur_frame);
-  }
-}
-
-
-
-void ComputeKaldiPitch(const PitchExtractionOptions &opts,
-                       const VectorBase<BaseFloat> &wave,
-                       Matrix<BaseFloat> *output) {
-  if (opts.simulate_first_pass_online) {
-    ComputeKaldiPitchFirstPass(opts, wave, output);
-    return;
-  }
-  OnlinePitchFeature pitch_extractor(opts);
-
-  if (opts.frames_per_chunk == 0) {
-    pitch_extractor.AcceptWaveform(opts.samp_freq, wave);
-  } else {
-    // the user may set opts.frames_per_chunk for better compatibility with
-    // online operation.
-    KALDI_ASSERT(opts.frames_per_chunk > 0);
-    int32 cur_offset = 0, samp_per_chunk =
-        opts.frames_per_chunk * opts.samp_freq * 1.0e-03 * opts.frame_shift_ms;
-    while (cur_offset < wave.Dim()) {
-      int32 num_samp = std::min(samp_per_chunk, wave.Dim() - cur_offset);
-      SubVector<BaseFloat> wave_chunk(wave, cur_offset, num_samp);
-      pitch_extractor.AcceptWaveform(opts.samp_freq, wave_chunk);
-      cur_offset += num_samp;
-    }
-  }
-  pitch_extractor.InputFinished();
-  int32 num_frames = pitch_extractor.NumFramesReady();
-  if (num_frames == 0) {
-    KALDI_WARN << "No frames output in pitch extraction";
-    output->Resize(0, 0);
-    return;
-  }
-  output->Resize(num_frames, 2);
-  for (int32 frame = 0; frame < num_frames; frame++) {
-    SubVector<BaseFloat> row(*output, frame);
-    pitch_extractor.GetFrame(frame, &row);
-  }
-}
-
-
-/*
-  This comment describes our invesigation of how much latency the
-  online-processing algorithm introduces, i.e. how many frames you would
-  typically have to wait until the traceback converges, if you were to set the
-  --max-frames-latency to a very large value.
-  
-  This was done on a couple of files of language-id data.
-  
-  /home/dpovey/kaldi-online/src/featbin/compute-kaldi-pitch-feats --frames-per-chunk=10 --max-frames-latency=100 --verbose=4 --sample-frequency=8000 --resample-frequency=2600 "scp:head -n 2 data/train/wav.scp |" ark:/dev/null 2>&1   | grep Latency | wc
-   4871   24355  443991
- /home/dpovey/kaldi-online/src/featbin/compute-kaldi-pitch-feats --frames-per-chunk=10 --max-frames-latency=100 --verbose=4 --sample-frequency=8000 --resample-frequency=2600 "scp:head -n 2 data/train/wav.scp |" ark:/dev/null 2>&1  | grep Latency | grep 100 | wc
-   1534    7670  141128
-
-# as above, but with 50 instead of 10 in the --max-frames-latency and grep statements.
-   2070   10350  188370
-# as above, but with 10 instead of 50.
-   4067   20335  370097
-
-   This says that out of 4871 selected frames [we measured the latency every 10
-   frames, since --frames-per-chunk=10], in 1534 frames (31%), the latency was
-    >= 100 frames, i.e. >= 1 second.  Including the other numbers, we can see
-    that
-
-    31% of frames had latency >= 1 second
-    42% of frames had latency >= 0.5 second
-    83% of frames had latency >= 0.1 second.
-
-  This doesn't necessarily mean that we actually have a latency of >= 1 second 31% of
-  the time when using these features, since by using the --max-frames-latency option
-  (default: 30 frames), it will limit the latency to, say, 0.3 seconds, and trace back
-  from the best current pitch.  Most of the time this will probably cause no change in
-  the pitch traceback since the best current pitch is probably the "right" point to
-  trace back from.  And anyway, in the online-decoding, we will most likely rescore
-  the features at the end anyway, and the traceback gets recomputed, so there will
-  be no inaccuracy (assuming the first-pass lattice had everything we needed).
-
-  Probably the greater source of inaccuracy due to the online algorithm is the
-  online energy-normalization, which affects the NCCF-ballast term, and which,
-  for reasons of efficiency, we don't attempt to "correct" in a later rescoring
-  pass.  This will make the most difference in the first few frames of the file,
-  before the first voicing, where it will tend to produce more pitch movement
-  than the offline version of the algorithm.  
-*/
-   
-
-// Function to do data accumulation for on-line usage
-template<typename Real>
-inline void AppendVector(const VectorBase<Real> &src, Vector<Real> *dst) {
-  if (src.Dim() == 0) return;
-  dst->Resize(dst->Dim() + src.Dim(), kCopyData);
-  dst->Range(dst->Dim() - src.Dim(), src.Dim()).CopyFromVec(src);
-}
-
-/**
-   Note on the implementation of OnlineProcessPitch: the
-   OnlineFeatureInterface allows random access to features (i.e. not necessarily
-   sequential order), so we need to support that.  But we don't need to support
-   it very efficiently, and our implementation is most efficient if frames are
-   accessed in sequential order.
-   
-   Also note: we have to be a bit careful in this implementation because
-   the input features may change.  That is: if we call
-   src_->GetFrame(t, &vec) from GetFrame(), we can't guarantee that a later
-   call to src_->GetFrame(t, &vec) from another GetFrame() will return the
-   same value.  In fact, while designing this class we used some knowledge
-   of how the OnlinePitchFeature class works to minimize the amount of
-   re-querying we had to do.
-*/
-OnlineProcessPitch::OnlineProcessPitch(
-    const ProcessPitchOptions &opts,
-    OnlineFeatureInterface *src):
-    opts_(opts), src_(src),
-    dim_ ((opts.add_pov_feature ? 1 : 0)
-          + (opts.add_normalized_log_pitch ? 1 : 0)
-          + (opts.add_delta_pitch ? 1 : 0)
-          + (opts.add_raw_log_pitch ? 1 : 0)) {
-  KALDI_ASSERT(dim_ > 0 && 
-               " At least one of the pitch features should be chosen. "
-               "Check your post-process-pitch options.");
-  KALDI_ASSERT(src->Dim() == kRawFeatureDim &&
-               "Input feature must be pitch feature (should have dimension 2)");
-}
-
-
-void OnlineProcessPitch::GetFrame(int32 frame,
-                                  VectorBase<BaseFloat> *feat) {
-  int32 frame_delayed = frame < opts_.delay ? 0 : frame - opts_.delay;
-  KALDI_ASSERT(feat->Dim() == dim_ &&
-               frame_delayed < NumFramesReady());
-  int32 index = 0;
-  if (opts_.add_pov_feature)
-    (*feat)(index++) = GetPovFeature(frame_delayed);
-  if (opts_.add_normalized_log_pitch)
-    (*feat)(index++) = GetNormalizedLogPitchFeature(frame_delayed);
-  if (opts_.add_delta_pitch)
-    (*feat)(index++) = GetDeltaPitchFeature(frame_delayed);
-  if (opts_.add_raw_log_pitch)
-    (*feat)(index++) = GetRawLogPitchFeature(frame_delayed);
-  KALDI_ASSERT(index == dim_);
-}
-
-BaseFloat OnlineProcessPitch::GetPovFeature(int32 frame) const {
-  Vector<BaseFloat> tmp(kRawFeatureDim);
-  src_->GetFrame(frame, &tmp);  // (NCCF, pitch) from pitch extractor
-  BaseFloat nccf = tmp(0);
-  return opts_.pov_scale * NccfToPovFeature(nccf)
-      + opts_.pov_offset;
-}
-
-BaseFloat OnlineProcessPitch::GetDeltaPitchFeature(int32 frame) {
-  // Rather than computing the delta pitch directly in code here,
-  // which might seem easier, we accumulate a small window of features
-  // and call ComputeDeltas.  This might seem like overkill; the reason
-  // we do it this way is to ensure that the end effects (at file
-  // beginning and end) are handled in a consistent way.
-  int32 context = opts_.delta_window;
-  int32 start_frame = std::max(0, frame - context),
-      end_frame = std::min(frame + context + 1, src_->NumFramesReady()),
-      frames_in_window = end_frame - start_frame;
-  Matrix<BaseFloat> feats(frames_in_window, 1),
-      delta_feats;
-  
-  for (int32 f = start_frame; f < end_frame; f++)
-    feats(f - start_frame, 0) = GetRawLogPitchFeature(f);
-
-  DeltaFeaturesOptions delta_opts;
-  delta_opts.order = 1;
-  delta_opts.window = opts_.delta_window;  
-  ComputeDeltas(delta_opts, feats, &delta_feats);
-  while (delta_feature_noise_.size() <= static_cast<size_t>(frame)) {
-    delta_feature_noise_.push_back(RandGauss() *
-                                   opts_.delta_pitch_noise_stddev);
-  }
-  // note: delta_feats will have two columns, second contains deltas.
-  return (delta_feats(frame - start_frame, 1) + delta_feature_noise_[frame]) *
-      opts_.delta_pitch_scale;
-}
-
-BaseFloat OnlineProcessPitch::GetRawLogPitchFeature(int32 frame) const {
-  Vector<BaseFloat> tmp(kRawFeatureDim);
-  src_->GetFrame(frame, &tmp);
-  BaseFloat pitch = tmp(1);
-  KALDI_ASSERT(pitch > 0);
-  return Log(pitch);
-}
-
-BaseFloat OnlineProcessPitch::GetNormalizedLogPitchFeature(int32 frame) {
-  UpdateNormalizationStats(frame);
-  BaseFloat log_pitch = GetRawLogPitchFeature(frame),
-      avg_log_pitch = normalization_stats_[frame].sum_log_pitch_pov /
-        normalization_stats_[frame].sum_pov,
-      normalized_log_pitch = log_pitch - avg_log_pitch;
-  return normalized_log_pitch * opts_.pitch_scale;
-}
-
-
-// inline
-void OnlineProcessPitch::GetNormalizationWindow(int32 t,
-                                                int32 src_frames_ready,
-                                                int32 *window_begin,
-                                                int32 *window_end) const {
-  int32 left_context = opts_.normalization_left_context;
-  int32 right_context = opts_.normalization_right_context;
-  *window_begin = std::max(0, t - left_context);
-  *window_end = std::min(t + right_context + 1, src_frames_ready);
-}
-
-
-// Makes sure the entry in normalization_stats_ for this frame is up to date;
-// called from GetNormalizedLogPitchFeature.
-// the cur_num_frames and input_finished variables are needed because the
-// pitch features for a given frame may change as we see more data.
-void OnlineProcessPitch::UpdateNormalizationStats(int32 frame) {
-  KALDI_ASSERT(frame >= 0);
-  if (normalization_stats_.size() <= frame)
-    normalization_stats_.resize(frame + 1);
-  int32 cur_num_frames = src_->NumFramesReady();
-  bool input_finished = src_->IsLastFrame(cur_num_frames - 1);
-
-  NormalizationStats &this_stats = normalization_stats_[frame];
-  if (this_stats.cur_num_frames == cur_num_frames &&
-      this_stats.input_finished == input_finished) {
-    // Stats are fully up-to-date.
-    return;
-  }
-  int32 this_window_begin, this_window_end;  
-  GetNormalizationWindow(frame, cur_num_frames,
-                         &this_window_begin, &this_window_end);
-  
-  if (frame > 0) {
-    const NormalizationStats &prev_stats = normalization_stats_[frame - 1];
-    if (prev_stats.cur_num_frames == cur_num_frames &&
-        prev_stats.input_finished == input_finished) {
-      // we'll derive this_stats efficiently from prev_stats.
-      // Checking that cur_num_frames and input_finished have not changed
-      // ensures that the underlying features will not have changed.
-      this_stats = prev_stats;
-      int32 prev_window_begin, prev_window_end;
-      GetNormalizationWindow(frame - 1, cur_num_frames,
-                             &prev_window_begin, &prev_window_end);
-      if (this_window_begin != prev_window_begin) {
-        KALDI_ASSERT(this_window_begin == prev_window_begin + 1);
-        Vector<BaseFloat> tmp(kRawFeatureDim);
-        src_->GetFrame(prev_window_begin, &tmp);
-        BaseFloat accurate_pov = NccfToPov(tmp(0)),
-            log_pitch = Log(tmp(1));
-        this_stats.sum_pov -= accurate_pov;
-        this_stats.sum_log_pitch_pov -= accurate_pov * log_pitch;
-      }
-      if (this_window_end != prev_window_end) {
-        KALDI_ASSERT(this_window_end == prev_window_end + 1);
-        Vector<BaseFloat> tmp(kRawFeatureDim);
-        src_->GetFrame(prev_window_end, &tmp);
-        BaseFloat accurate_pov = NccfToPov(tmp(0)),
-            log_pitch = Log(tmp(1));
-        this_stats.sum_pov += accurate_pov;
-        this_stats.sum_log_pitch_pov += accurate_pov * log_pitch;
-      }
-      return;      
-    }
-  }
-  // The way we do it here is not the most efficient way to do it;
-  // we'll see if it becomes a problem.  The issue is we have to redo
-  // this computation from scratch each time we process a new chunk, which
-  // may be a little inefficient if the chunk-size is very small.
-  this_stats.cur_num_frames = cur_num_frames;
-  this_stats.input_finished = input_finished;
-  this_stats.sum_pov = 0.0;
-  this_stats.sum_log_pitch_pov = 0.0;
-  Vector<BaseFloat> tmp(kRawFeatureDim);
-  for (int32 f = this_window_begin; f < this_window_end; f++) {
-    src_->GetFrame(f, &tmp);
-    BaseFloat accurate_pov = NccfToPov(tmp(0)),
-        log_pitch = Log(tmp(1));
-    this_stats.sum_pov += accurate_pov;
-    this_stats.sum_log_pitch_pov += accurate_pov * log_pitch;
-  }
-}
-
-int32 OnlineProcessPitch::NumFramesReady() const {
-  int32 src_frames_ready = src_->NumFramesReady();
-  if (src_frames_ready == 0) {
-    return 0;
-  } else if (src_->IsLastFrame(src_frames_ready - 1)) {
-    return src_frames_ready + opts_.delay;
-  } else {
-    return std::max(0, src_frames_ready - 
-      opts_.normalization_right_context + opts_.delay);
-  }
-}
-
-void ProcessPitch(const ProcessPitchOptions &opts,
-                  const MatrixBase<BaseFloat> &input,
-                  Matrix<BaseFloat> *output) {
-  OnlineMatrixFeature pitch_feat(input);
-  
-  OnlineProcessPitch online_process_pitch(opts, &pitch_feat);
-
-  output->Resize(online_process_pitch.NumFramesReady(),
-                 online_process_pitch.Dim());
-  for (int32 t = 0; t < online_process_pitch.NumFramesReady(); t++) {
-    SubVector<BaseFloat> row(*output, t);
-    online_process_pitch.GetFrame(t, &row);
-  }
-}
-
-
-void ComputeAndProcessKaldiPitch(
-    const PitchExtractionOptions &pitch_opts,
-    const ProcessPitchOptions &process_opts,    
-    const VectorBase<BaseFloat> &wave,
-    Matrix<BaseFloat> *output) {
-  
-  OnlinePitchFeature pitch_extractor(pitch_opts);
-
-  if (pitch_opts.simulate_first_pass_online) {
-    KALDI_ASSERT(pitch_opts.frames_per_chunk > 0 &&
-                 "--simulate-first-pass-online option does not make sense "
-                 "unless you specify --frames-per-chunk");
-  }
-
-  OnlineProcessPitch post_process(process_opts, &pitch_extractor);
-
-  int32 cur_rows = 100;
-  Matrix<BaseFloat> feats(cur_rows, post_process.Dim());
-  
-  int32 cur_offset = 0, cur_frame = 0,
-      samp_per_chunk = pitch_opts.frames_per_chunk *
-      pitch_opts.samp_freq * 1.0e-03 * pitch_opts.frame_shift_ms;
-
-  // We request the first-pass features as soon as they are available,
-  // regardless of whether opts.simulate_first_pass_online == true.  If
-  // opts.simulate_first_pass_online == true this should
-  // not affect the features generated, but it helps us to test the code
-  // in a way that's closer to what online decoding would see.
-  
-  while (cur_offset < wave.Dim()) {
-    int32 num_samp;
-    if (samp_per_chunk > 0)
-      num_samp = std::min(samp_per_chunk, wave.Dim() - cur_offset);
-    else  // user left opts.frames_per_chunk at zero.
-      num_samp = wave.Dim();
-    SubVector<BaseFloat> wave_chunk(wave, cur_offset, num_samp);
-    pitch_extractor.AcceptWaveform(pitch_opts.samp_freq, wave_chunk);
-    cur_offset += num_samp;
-    if (cur_offset == wave.Dim())
-      pitch_extractor.InputFinished();
-    
-    // Get each frame as soon as it is ready.
-    for (; cur_frame < post_process.NumFramesReady(); cur_frame++) {
-      if (cur_frame >= cur_rows) {
-        cur_rows *= 2;
-        feats.Resize(cur_rows, post_process.Dim(), kCopyData);
-      }
-      SubVector<BaseFloat> row(feats, cur_frame);
-      post_process.GetFrame(cur_frame, &row);
-    }
-  }
-  
-  if (pitch_opts.simulate_first_pass_online) {
-    if (cur_frame == 0) {
-      KALDI_WARN << "No features output since wave file too short";
-      output->Resize(0, 0);
-    } else {
-      *output = feats.RowRange(0, cur_frame);
-    }
-  } else {
-    // want the "final" features for second pass, so get them again.
-    output->Resize(post_process.NumFramesReady(), post_process.Dim());
-    for (int32 frame = 0; frame < post_process.NumFramesReady(); frame++) {
-      SubVector<BaseFloat> row(*output, frame);
-      post_process.GetFrame(frame, &row);
-    }
-  }
-}
-
-
-}  // namespace kaldi
diff --git src/feat/pitch-functions.h src/feat/pitch-functions.h
deleted file mode 100644
index fd9ead0..0000000
--- src/feat/pitch-functions.h
+++ /dev/null
@@ -1,447 +0,0 @@
-// feat/pitch-functions.h
-
-// Copyright     2013  Pegah Ghahremani
-//               2014  IMSL, PKU-HKUST (author: Wei Shi)
-//               2014  Yanqing Sun, Junjie Wang,
-//                     Daniel Povey, Korbinian Riedhammer
-//                     Xin Lei
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#ifndef KALDI_FEAT_PITCH_FUNCTIONS_H_
-#define KALDI_FEAT_PITCH_FUNCTIONS_H_
-
-#include <cassert>
-#include <cstdlib>
-#include <string>
-#include <vector>
-
-#include "base/kaldi-error.h"
-#include "feat/mel-computations.h"
-#include "itf/online-feature-itf.h"
-#include "matrix/matrix-lib.h"
-#include "util/common-utils.h"
-
-namespace kaldi {
-/// @addtogroup  feat FeatureExtraction
-/// @{
-
-struct PitchExtractionOptions {
-  // FrameExtractionOptions frame_opts;
-  BaseFloat samp_freq;          // sample frequency in hertz
-  BaseFloat frame_shift_ms;     // in milliseconds.
-  BaseFloat frame_length_ms;    // in milliseconds.
-  BaseFloat preemph_coeff;      // Preemphasis coefficient. [use is deprecated.]
-  BaseFloat min_f0;             // min f0 to search (Hz)
-  BaseFloat max_f0;             // max f0 to search (Hz)
-  BaseFloat soft_min_f0;        // Minimum f0, applied in soft way, must not
-                                // exceed min-f0
-  BaseFloat penalty_factor;     // cost factor for FO change
-  BaseFloat lowpass_cutoff;     // cutoff frequency for Low pass filter
-  BaseFloat resample_freq;      // Integer that determines filter width when
-                                // upsampling NCCF
-  BaseFloat delta_pitch;        // the pitch tolerance in pruning lags
-  BaseFloat nccf_ballast;       // Increasing this factor reduces NCCF for
-                                // quiet frames, helping ensure pitch
-                                // continuity in unvoiced region
-  int32 lowpass_filter_width;   // Integer that determines filter width of
-                                // lowpass filter
-  int32 upsample_filter_width;  // Integer that determines filter width when
-                                // upsampling NCCF
-
-  // Below are newer config variables, not present in the original paper,
-  // that relate to the online pitch extraction algorithm.
-
-  // The maximum number of frames of latency that we allow the pitch-processing
-  // to introduce, for online operation. If you set this to a large value,
-  // there would be no inaccuracy from the Viterbi traceback (but it might make
-  // you wait to see the pitch). This is not very relevant for the online
-  // operation: normalization-right-context is more relevant, you
-  // can just leave this value at zero.
-  int32 max_frames_latency;
-
-  // Only relevant for the function ComputeKaldiPitch which is called by
-  // compute-kaldi-pitch-feats. If nonzero, we provide the input as chunks of
-  // this size. This affects the energy normalization which has a small effect
-  // on the resulting features, especially at the beginning of a file. For best
-  // compatibility with online operation (e.g. if you plan to train models for
-  // the online-deocding setup), you might want to set this to a small value,
-  // like one frame.
-  int32 frames_per_chunk;
-
-  // Only relevant for the function ComputeKaldiPitch which is called by
-  // compute-kaldi-pitch-feats, and only relevant if frames_per_chunk is
-  // nonzero. If true, it will query the features as soon as they are
-  // available, which simulates the first-pass features you would get in online
-  // decoding. If false, the features you will get will be the same as those
-  // available at the end of the utterance, after InputFinished() has been
-  // called: e.g. during lattice rescoring.
-  bool simulate_first_pass_online;
-
-  // Only relevant for online operation or when emulating online operation
-  // (e.g. when setting frames_per_chunk). This is the frame-index on which we
-  // recompute the NCCF (e.g. frame-index 500 = after 5 seconds); if the
-  // segment ends before this we do it when the segment ends. We do this by
-  // re-computing the signal average energy, which affects the NCCF via the
-  // "ballast term", scaling the resampled NCCF by a factor derived from the
-  // average change in the "ballast term", and re-doing the backtrace
-  // computation. Making this infinity would be the most exact, but would
-  // introduce unwanted latency at the end of long utterances, for little
-  // benefit.
-  int32 recompute_frame;
-
-  // This is a "hidden config" used only for testing the online pitch
-  // extraction. If true, we compute the signal root-mean-squared for the
-  // ballast term, only up to the current frame, rather than the end of the
-  // current chunk of signal. This makes the output insensitive to the
-  // chunking, which is useful for testing purposes.
-  bool nccf_ballast_online;
-  bool snip_edges;
-  PitchExtractionOptions():
-      samp_freq(16000),
-      frame_shift_ms(10.0),
-      frame_length_ms(25.0),
-      preemph_coeff(0.0),
-      min_f0(50),
-      max_f0(400),
-      soft_min_f0(10.0),
-      penalty_factor(0.1),
-      lowpass_cutoff(1000),
-      resample_freq(4000),
-      delta_pitch(0.005),
-      nccf_ballast(7000),
-      lowpass_filter_width(1),
-      upsample_filter_width(5),
-      max_frames_latency(0),
-      frames_per_chunk(0),
-      simulate_first_pass_online(false),
-      recompute_frame(500),
-      nccf_ballast_online(false),
-      snip_edges(true) { }
-
-  void Register(OptionsItf *opts) {
-    opts->Register("sample-frequency", &samp_freq,
-                   "Waveform data sample frequency (must match the waveform "
-                   "file, if specified there)");
-    opts->Register("frame-length", &frame_length_ms, "Frame length in "
-                   "milliseconds");
-    opts->Register("frame-shift", &frame_shift_ms, "Frame shift in milliseconds");
-    opts->Register("preemphasis-coefficient", &preemph_coeff,
-                   "Coefficient for use in signal preemphasis (deprecated)");
-    opts->Register("min-f0", &min_f0,
-                   "min. F0 to search for (Hz)");
-    opts->Register("max-f0", &max_f0,
-                   "max. F0 to search for (Hz)");
-    opts->Register("soft-min-f0", &soft_min_f0,
-                   "Minimum f0, applied in soft way, must not exceed min-f0");
-    opts->Register("penalty-factor", &penalty_factor,
-                   "cost factor for FO change.");
-    opts->Register("lowpass-cutoff", &lowpass_cutoff,
-                   "cutoff frequency for LowPass filter (Hz) ");
-    opts->Register("resample-frequency", &resample_freq,
-                   "Frequency that we down-sample the signal to.  Must be "
-                   "more than twice lowpass-cutoff");
-    opts->Register("delta-pitch", &delta_pitch,
-                   "Smallest relative change in pitch that our algorithm "
-                   "measures");
-    opts->Register("nccf-ballast", &nccf_ballast,
-                   "Increasing this factor reduces NCCF for quiet frames");
-    opts->Register("nccf-ballast-online", &nccf_ballast_online,
-                   "This is useful mainly for debug; it affects how the NCCF "
-                   "ballast is computed.");
-    opts->Register("lowpass-filter-width", &lowpass_filter_width,
-                   "Integer that determines filter width of "
-                   "lowpass filter, more gives sharper filter");
-    opts->Register("upsample-filter-width", &upsample_filter_width,
-                   "Integer that determines filter width when upsampling NCCF");
-    opts->Register("frames-per-chunk", &frames_per_chunk, "Only relevant for "
-                   "offline pitch extraction (e.g. compute-kaldi-pitch-feats), "
-                   "you can set it to a small nonzero value, such as 10, for "
-                   "better feature compatibility with online decoding (affects "
-                   "energy normalization in the algorithm)");
-    opts->Register("simulate-first-pass-online", &simulate_first_pass_online,
-                   "If true, compute-kaldi-pitch-feats will output features "
-                   "that correspond to what an online decoder would see in the "
-                   "first pass of decoding-- not the final version of the "
-                   "features, which is the default.  Relevant if "
-                   "--frames-per-chunk > 0");
-    opts->Register("recompute-frame", &recompute_frame, "Only relevant for "
-                   "online pitch extraction, or for compatibility with online "
-                   "pitch extraction.  A non-critical parameter; the frame at "
-                   "which we recompute some of the forward pointers, after "
-                   "revising our estimate of the signal energy.  Relevant if"
-                   "--frames-per-chunk > 0");
-    opts->Register("max-frames-latency", &max_frames_latency, "Maximum number "
-                   "of frames of latency that we allow pitch tracking to "
-                   "introduce into the feature processing (affects output only "
-                   "if --frames-per-chunk > 0 and "
-                   "--simulate-first-pass-online=true");
-    opts->Register("snip-edges", &snip_edges, "If this is set to false, the "
-                   "incomplete frames near the ending edge won't be snipped, so "
-                   "that the number of frames is the file size divided by the "
-                   "frame-shift. This makes different types of features give the "
-                   "same number of frames.");
-
-  }
-  /// Returns the window-size in samples, after resampling.  This is the
-  /// "basic window size", not the full window size after extending by max-lag.
-  int32 NccfWindowSize() const {
-    return static_cast<int32>(resample_freq * 0.001 * frame_length_ms);
-  }
-  /// Returns the window-shift in samples, after resampling.
-  int32 NccfWindowShift() const {
-    return static_cast<int32>(resample_freq * 0.001 * frame_shift_ms);
-  }
-};
-
-struct ProcessPitchOptions {
-  BaseFloat pitch_scale;  // the final normalized-log-pitch feature is scaled
-                          // with this value
-  BaseFloat pov_scale;    // the final POV feature is scaled with this value
-  BaseFloat pov_offset;   // An offset that can be added to the final POV
-                          // feature (useful for online-decoding, where we don't
-                          // do CMN to the pitch-derived features.
-
-  BaseFloat delta_pitch_scale;
-  BaseFloat delta_pitch_noise_stddev;  // stddev of noise we add to delta-pitch
-  int32 normalization_left_context;    // left-context used for sliding-window
-                                       // normalization
-  int32 normalization_right_context;   // this should be reduced in online
-                                       // decoding to reduce latency
-
-  int32 delta_window;
-  int32 delay;
-  
-  bool add_pov_feature;  
-  bool add_normalized_log_pitch;  
-  bool add_delta_pitch;
-  bool add_raw_log_pitch;
-  
-  ProcessPitchOptions() :
-      pitch_scale(2.0),
-      pov_scale(2.0),
-      pov_offset(0.0),
-      delta_pitch_scale(10.0),
-      delta_pitch_noise_stddev(0.005),
-      normalization_left_context(75),
-      normalization_right_context(75),
-      delta_window(2),
-      delay(0),
-      add_pov_feature(true),
-      add_normalized_log_pitch(true),
-      add_delta_pitch(true),
-      add_raw_log_pitch(false) { }
-
-
-  void Register(ParseOptions *opts) {
-    opts->Register("pitch-scale", &pitch_scale,
-                   "Scaling factor for the final normalized log-pitch value");
-    opts->Register("pov-scale", &pov_scale,
-                   "Scaling factor for final POV (probability of voicing) "
-                   "feature");
-    opts->Register("pov-offset", &pov_offset,
-                   "This can be used to add an offset to the POV feature. "
-                   "Intended for use in online decoding as a substitute for "
-                   " CMN.");
-    opts->Register("delta-pitch-scale", &delta_pitch_scale,
-                   "Term to scale the final delta log-pitch feature");
-    opts->Register("delta-pitch-noise-stddev", &delta_pitch_noise_stddev,
-                   "Standard deviation for noise we add to the delta log-pitch "
-                   "(before scaling); should be about the same as delta-pitch "
-                   "option to pitch creation.  The purpose is to get rid of "
-                   "peaks in the delta-pitch caused by discretization of pitch "
-                   "values.");
-    opts->Register("normalization-left-context", &normalization_left_context,
-                   "Left-context (in frames) for moving window normalization");
-    opts->Register("normalization-right-context", &normalization_right_context,
-                   "Right-context (in frames) for moving window normalization");
-    opts->Register("delta-window", &delta_window,
-                   "Number of frames on each side of central frame, to use for "
-                   "delta window.");
-    opts->Register("delay", &delay,
-                   "Number of frames by which the pitch information is delayed.");
-    opts->Register("add-pov-feature", &add_pov_feature,
-                   "If true, the warped NCCF is added to output features");
-    opts->Register("add-normalized-log-pitch", &add_normalized_log_pitch,
-                   "If true, the log-pitch with POV-weighted mean subtraction "
-                   "over 1.5 second window is added to output features");
-    opts->Register("add-delta-pitch", &add_delta_pitch,
-                   "If true, time derivative of log-pitch is added to output "
-                   "features");
-    opts->Register("add-raw-log-pitch", &add_raw_log_pitch,
-                   "If true, log(pitch) is added to output features");
-  }
-};
-
-
-// We don't want to expose the pitch-extraction internals here as it's
-// quite complex, so we use a private implementation.
-class OnlinePitchFeatureImpl;
-
-
-// Note: to start on a new waveform, just construct a new version
-// of this object.
-class OnlinePitchFeature: public OnlineBaseFeature {
- public:
-  explicit OnlinePitchFeature(const PitchExtractionOptions &opts);
-
-  virtual int32 Dim() const { return 2; /* (NCCF, pitch) */ }
-
-  virtual int32 NumFramesReady() const;
-  
-  virtual BaseFloat FrameShiftInSeconds() const;
-
-  virtual bool IsLastFrame(int32 frame) const;
-
-  /// Outputs the two-dimensional feature consisting of (pitch, NCCF).  You
-  /// should probably post-process this using class OnlineProcessPitch.
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  virtual void AcceptWaveform(BaseFloat sampling_rate,
-                              const VectorBase<BaseFloat> &waveform);
-
-  virtual void InputFinished();
-
-  virtual ~OnlinePitchFeature();
-
- private:
-  OnlinePitchFeatureImpl *impl_;
-};
-
-
-/// This online-feature class implements post processing of pitch features.
-/// Inputs are original 2 dims (nccf, pitch).  It can produce various
-/// kinds of outputs, using the default options it will be (pov-feature,
-/// normalized-log-pitch, delta-log-pitch).
-class OnlineProcessPitch: public OnlineFeatureInterface {
- public:
-  virtual int32 Dim() const { return dim_; }
-
-  virtual bool IsLastFrame(int32 frame) const {
-    if (frame <= -1)
-      return src_->IsLastFrame(-1);
-    else if (frame < opts_.delay) 
-      return src_->IsLastFrame(-1) == true ? false : src_->IsLastFrame(0);
-    else
-      return src_->IsLastFrame(frame - opts_.delay); 
-  }
-  virtual BaseFloat FrameShiftInSeconds() const {
-    return src_->FrameShiftInSeconds();
-  }
-
-  virtual int32 NumFramesReady() const;
-
-  virtual void GetFrame(int32 frame, VectorBase<BaseFloat> *feat);
-
-  virtual ~OnlineProcessPitch() {  }
-
-  // Does not take ownership of "src".
-  OnlineProcessPitch(const ProcessPitchOptions &opts,
-                     OnlineFeatureInterface *src);
-
- private:
-  enum { kRawFeatureDim = 2}; // anonymous enum to define a constant. 
-                              // kRawFeatureDim defines the dimension 
-                              // of the input: (nccf, pitch)
-
-  ProcessPitchOptions opts_;
-  OnlineFeatureInterface *src_;
-  int32 dim_;  // Output feature dimension, set in initializer.
-
-  struct NormalizationStats {
-    int32 cur_num_frames;      // value of src_->NumFramesReady() when
-                               // "mean_pitch" was set.
-    bool input_finished;       // true if input data was finished when
-                               // "mean_pitch" was computed.
-    double sum_pov;            // sum of pov over relevant range
-    double sum_log_pitch_pov;  // sum of log(pitch) * pov over relevant range
-
-    NormalizationStats(): cur_num_frames(-1), input_finished(false),
-                          sum_pov(0.0), sum_log_pitch_pov(0.0) { }
-  };
-
-  std::vector<BaseFloat> delta_feature_noise_;
-
-  std::vector<NormalizationStats> normalization_stats_;
-
-  /// Computes and returns the POV feature for this frame.
-  /// Called from GetFrame().  
-  inline BaseFloat GetPovFeature(int32 frame) const;  
-
-  /// Computes and returns the delta-log-pitch feature for this frame.
-  /// Called from GetFrame().
-  inline BaseFloat GetDeltaPitchFeature(int32 frame);
-
-  /// Computes and returns the raw log-pitch feature for this frame.
-  /// Called from GetFrame().  
-  inline BaseFloat GetRawLogPitchFeature(int32 frame) const;
-
-  /// Computes and returns the mean-subtracted log-pitch feature for this frame.
-  /// Called from GetFrame().
-  inline BaseFloat GetNormalizedLogPitchFeature(int32 frame);
-
-  /// Computes the normalization window sizes.
-  inline void GetNormalizationWindow(int32 frame,
-                                     int32 src_frames_ready,
-                                     int32 *window_begin,
-                                     int32 *window_end) const;
-
-  /// Makes sure the entry in normalization_stats_ for this frame is up to date;
-  /// called from GetNormalizedLogPitchFeature.
-  inline void UpdateNormalizationStats(int32 frame);
-};
-
-
-/// This function extracts (pitch, NCCF) per frame, using the pitch extraction
-/// method described in "A Pitch Extraction Algorithm Tuned for Automatic Speech
-/// Recognition", Pegah Ghahremani, Bagher BabaAli, Daniel Povey, Korbinian
-/// Riedhammer, Jan Trmal and Sanjeev Khudanpur, ICASSP 2014.  The output will
-/// have as many rows as there are frames, and two columns corresponding to
-/// (NCCF, pitch)
-void ComputeKaldiPitch(const PitchExtractionOptions &opts,
-                       const VectorBase<BaseFloat> &wave,
-                       Matrix<BaseFloat> *output);
-
-/// This function processes the raw (NCCF, pitch) quantities computed by
-/// ComputeKaldiPitch, and processes them into features.  By default it will
-/// output three-dimensional features, (POV-feature, mean-subtracted-log-pitch,
-/// delta-of-raw-pitch), but this is configurable in the options.  The number of
-/// rows of "output" will be the number of frames (rows) in "input", and the
-/// number of columns will be the number of different types of features
-/// requested (by default, 3; 4 is the max).  The four config variables
-/// --add-pov-feature, --add-normalized-log-pitch, --add-delta-pitch,
-/// --add-raw-log-pitch determine which features we create; by default we create
-/// the first three.
-void ProcessPitch(const ProcessPitchOptions &opts,
-                  const MatrixBase<BaseFloat> &input,
-                  Matrix<BaseFloat> *output);
-
-/// This function combines ComputeKaldiPitch and ProcessPitch.  The reason
-/// why we need a separate function to do this is in order to be able to
-/// accurately simulate the online pitch-processing, for testing and for
-/// training models matched to the "first-pass" features.  It is sensitive to
-/// the variables in pitch_opts that relate to online processing,
-/// i.e. max_frames_latency, frames_per_chunk, simulate_first_pass_online,
-/// recompute_frame.
-void ComputeAndProcessKaldiPitch(const PitchExtractionOptions &pitch_opts,
-                                 const ProcessPitchOptions &process_opts,
-                                 const VectorBase<BaseFloat> &wave,
-                                 Matrix<BaseFloat> *output);
-
-
-/// @} End of "addtogroup feat"
-}  // namespace kaldi
-#endif  // KALDI_FEAT_PITCH_FUNCTIONS_H_
diff --git src/feat/resample-test.cc src/feat/resample-test.cc
deleted file mode 100644
index ad56d2b..0000000
--- src/feat/resample-test.cc
+++ /dev/null
@@ -1,293 +0,0 @@
-// feat/resample-test.cc
-
-// Copyright    2013  Pegah Ghahremani
-//              2014  IMSL, PKU-HKUST (author: Wei Shi)
-//              2014  Yanqing Sun, Junjie Wang
-//              2014  Johns Hopkins University (author: Daniel Povey)
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include "feat/resample.h"
-
-using namespace kaldi;
-
-class TestFunction {
- public:
-  explicit TestFunction(double frequency):
-      frequency_(frequency),
-      sin_magnitude_(RandGauss()),
-      cos_magnitude_(RandGauss()) { }
-
-  double operator() (double t) const {
-    double omega_t = t * M_2PI * frequency_;
-    return sin_magnitude_ * sin(omega_t)
-        + cos_magnitude_ * cos(omega_t);
-  }
- private:
-  double frequency_;
-  double sin_magnitude_;
-  double cos_magnitude_;
-};
-
-
-void UnitTestArbitraryResample() {
-  BaseFloat samp_freq = 1000.0 * (1.0 + RandUniform());
-  int32 num_samp = 256 + static_cast<int32>((RandUniform() * 256));
-
-  BaseFloat time_interval = num_samp / samp_freq;
-
-  // Choose a lowpass frequency that's lower than 95% of the Nyquist.
-  BaseFloat lowpass_freq = samp_freq * 0.95 * 0.5 / (1.0 + RandUniform());
-
-  // Number of zeros of the sinc function that the window extends out to.
-  int32 num_zeros = 3 + rand() % 10;
-
-  // Resample the signal at arbitrary points within that time interval.
-  int32 num_resamp = 50 + rand() % 100;  // Resample at around 100 points,
-                                         // anywhere in the signal.
-
-
-  Vector<BaseFloat> resample_points(num_resamp);
-  for (int32 i = 0; i < num_resamp; i++) {
-    // the if-statement is to make some of the resample_points
-    // exactly coincide with the original points, to activate
-    // a certain code path.
-    if (rand() % 2 == 0)
-      resample_points(i) = (rand() % num_samp) / samp_freq;
-    else
-      resample_points(i) = RandUniform() * time_interval;
-  }
-
-
-
-  BaseFloat window_width = num_zeros / (2.0 * lowpass_freq);
-  // the resampling should be quite accurate if we are further
-  // than filter_width away from the edges.
-  BaseFloat min_t = 0.0 + window_width,
-      max_t = time_interval - (1.0 / samp_freq) - window_width;
-
-  // window_freq gives us a rough idea of the frequency spread
-  // that the windowing function gives us; we want the test frequency
-  // to be lower than the lowpass frequency by at least this much.
-  // (note: the real width of the window from side to side
-  // is 2.0 * window_width)
-  BaseFloat window_freq = 1.0 / (2.0 * window_width),
-      freq_margin = 2.0 * window_freq;
-
-  // Choose a test-signal frequency that's lower than
-  // lowpass_freq - freq_margin.
-  BaseFloat test_signal_freq =
-    (lowpass_freq - freq_margin) * (1.0 / (1.0 + RandUniform()));
-
-  KALDI_ASSERT(test_signal_freq > 0.0);
-
-  ArbitraryResample resampler(num_samp, samp_freq, lowpass_freq,
-                              resample_points, num_zeros);
-
-
-  TestFunction test_func(test_signal_freq);
-
-  // test with a one-row matrix equal to the test signal.
-  Matrix<BaseFloat> sample_values(1, num_samp);
-  for (int32 i = 0; i < num_samp; i++) {
-    BaseFloat t = i / samp_freq;
-    sample_values(0, i) = test_func(t);
-  }
-  Matrix<BaseFloat> resampled_values(1, num_resamp);
-
-
-  if (rand() % 2 == 0) {
-    resampler.Resample(sample_values,
-                       &resampled_values);
-  } else {
-    SubVector<BaseFloat> out(resampled_values, 0);
-    resampler.Resample(sample_values.Row(0),
-                       &out);
-  }
-
-
-  for (int32 i = 0; i < num_resamp; i++) {
-    BaseFloat t = resample_points(i),
-        x1 = test_func(t),
-        x2 = resampled_values(0, i),
-        error = fabs(x1 - x2);
-    if (i % 10 == 0) {
-      KALDI_VLOG(1) << "Error is " << error << ", t = " << t
-                << ", samp_freq = " << samp_freq << ", lowpass_freq = "
-                << lowpass_freq << ", test_freq = " << test_signal_freq
-                << ", num-zeros is " << num_zeros;
-    }
-    if (t > min_t && t < max_t) {
-      if (num_zeros == 3) {
-        KALDI_ASSERT(error < 0.1);
-      } else {
-        KALDI_ASSERT(error < 0.025);
-      }
-    } else {
-      KALDI_VLOG(1) << "[not checking since out of bounds]";
-    }
-  }
-}
-
-
-void UnitTestLinearResample() {
-  // this test makes sure that LinearResample gives identical results to
-  // ArbitraryResample when set up the same way, even if the signal is broken up
-  // into many pieces.
-
-  int32 samp_freq = 1000.0 * (1.0 + RandUniform()),
-      resamp_freq = 1000.0 * (1.0 + RandUniform());
-  // note: these are both integers!
-  int32 num_samp = 256 + static_cast<int32>((RandUniform() * 256));
-
-  BaseFloat time_interval = num_samp / static_cast<BaseFloat>(samp_freq);
-
-  // Choose a lowpass frequency that's lower than 95% of the Nyquist of both
-  // of the frequencies..
-  BaseFloat lowpass_freq =
-    std::min(samp_freq, resamp_freq) * 0.95 * 0.5 / (1.0 + RandUniform());
-
-  // Number of zeros of the sinc function that the window extends out to.
-  int32 num_zeros = 3 + rand() % 10;
-
-  // compute the number of "resample" points.
-  int32 num_resamp = ceil(time_interval * resamp_freq);
-
-  Vector<BaseFloat> resample_points(num_resamp);
-  for (int32 i = 0; i < num_resamp; i++)
-    resample_points(i) = i / static_cast<BaseFloat>(resamp_freq);
-
-
-  Vector<BaseFloat> test_signal(num_samp);
-  test_signal.SetRandn();
-
-  ArbitraryResample resampler(num_samp, samp_freq, lowpass_freq,
-                              resample_points, num_zeros);
-
-
-  // test with a one-row matrix equal to the test signal.
-  Matrix<BaseFloat> sample_values(1, num_samp);
-  sample_values.Row(0).CopyFromVec(test_signal);
-
-  Matrix<BaseFloat> resampled_values(1, num_resamp);
-
-  resampler.Resample(sample_values,
-                     &resampled_values);
-
-  LinearResample linear_resampler(samp_freq, resamp_freq,
-                                  lowpass_freq, num_zeros);
-
-  Vector<BaseFloat> resampled_vec;
-
-  linear_resampler.Resample(test_signal, true, &resampled_vec);
-
-  if (!ApproxEqual(resampled_values.Row(0), resampled_vec)) {
-    KALDI_LOG << "ArbitraryResample: " << resampled_values.Row(0);
-    KALDI_LOG << "LinearResample: " << resampled_vec;
-    KALDI_ERR << "Signals differ.";
-  }
-
-  // Check it gives the same results when the input is broken up into pieces.
-  Vector<BaseFloat> resampled_vec2;
-  int32 input_dim_seen = 0;
-  while (input_dim_seen < test_signal.Dim()) {
-    int32 dim_remaining = test_signal.Dim() - input_dim_seen;
-    int32 piece_size = rand() % std::min(dim_remaining + 1, 10);
-    KALDI_VLOG(1) << "Piece size = " << piece_size;
-    SubVector<BaseFloat> in_piece(test_signal, input_dim_seen, piece_size);
-    Vector<BaseFloat> out_piece;
-    bool flush = (piece_size == dim_remaining);
-    linear_resampler.Resample(in_piece, flush, &out_piece);
-    int32 old_output_dim = resampled_vec2.Dim();
-    resampled_vec2.Resize(old_output_dim + out_piece.Dim(), kCopyData);
-    resampled_vec2.Range(old_output_dim, out_piece.Dim())
-                  .CopyFromVec(out_piece);
-    input_dim_seen += piece_size;
-  }
-
-  if (!ApproxEqual(resampled_values.Row(0), resampled_vec2)) {
-    KALDI_LOG << "ArbitraryResample: " << resampled_values.Row(0);
-    KALDI_LOG << "LinearResample[broken-up]: " << resampled_vec2;
-    KALDI_ERR << "Signals differ.";
-  }
-}
-
-void UnitTestLinearResample2() {
-  int32 num_samp = 150 + rand() % 100;
-  BaseFloat samp_freq = 1000, resamp_freq = 4000;
-
-  int32 num_zeros = 10; // fairly accurate.
-  Vector<BaseFloat> signal_orig(num_samp);
-  signal_orig.SetRandn();
-
-  Vector<BaseFloat> signal(num_samp);  
-  { // make sure signal is sufficiently low pass, i.e. that we have enough
-    // headroom before the Nyquist.
-    LinearResample linear_resampler_filter(samp_freq, samp_freq,
-                                           0.8 * samp_freq / 2.0, num_zeros);
-    linear_resampler_filter.Resample(signal_orig, true, &signal);
-  }
-  
-
-  Vector<BaseFloat> signal_upsampled;
-
-  LinearResample linear_resampler(samp_freq, resamp_freq,
-                                  samp_freq / 2.0, num_zeros);
-
-  linear_resampler.Resample(signal, true, &signal_upsampled);
-
-  // resample back to the original frequency.
-  LinearResample linear_resampler2(resamp_freq, samp_freq,
-                                   samp_freq / 2.0, num_zeros);
-  
-  
-  Vector<BaseFloat> signal_downsampled;  
-  linear_resampler2.Resample(signal_upsampled, true, &signal_downsampled);
-
-
-  int32 samp_discard = 30;  // Discard 20 samples for edge effects.
-  SubVector<BaseFloat> signal_middle(signal, samp_discard,
-                                     signal.Dim() - (2 * samp_discard));
-
-  SubVector<BaseFloat> signal2_middle(signal_downsampled, samp_discard,
-                                      signal.Dim() - (2 * samp_discard));
-
-  BaseFloat self1 = VecVec(signal_middle, signal_middle),
-      self2 = VecVec(signal2_middle, signal2_middle),
-      cross = VecVec(signal_middle, signal2_middle);
-  KALDI_LOG << "Self1 = " << self1 << ", self2 = " << self2
-            << ", cross = " << cross;
-  AssertEqual(self1, self2, 0.001);
-  AssertEqual(self1, cross, 0.001);
-}
-
-int main() {
-  try {
-    for (int32 x = 0; x < 50; x++)
-      UnitTestLinearResample();
-    for (int32 x = 0; x < 50; x++)
-      UnitTestLinearResample2();    
-    for (int32 x = 0; x < 50; x++)
-      UnitTestArbitraryResample();
-
-    KALDI_LOG << "Tests succeeded.\n";
-    return 0;
-  } catch(const std::exception &e) {
-    KALDI_ERR << e.what();
-    return 1;
-  }
-}
diff --git src/feat/signal-test.cc src/feat/signal-test.cc
deleted file mode 100644
index 39a3790..0000000
--- src/feat/signal-test.cc
+++ /dev/null
@@ -1,63 +0,0 @@
-// feat/signal-test.cc
-
-// Copyright 2015  Tom Ko
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-#include "base/kaldi-common.h"
-#include "util/common-utils.h"
-#include "feat/signal.h"
-
-namespace kaldi {
-
-void UnitTestBlockConvolution() {
-  for (int32 i = 0; i < 5; i++) {
-    int32 signal_length = 4000000 + Rand() % 400000;
-    int32 filter_length = 10000 + Rand() % 1000;
-    Vector<BaseFloat> signal(signal_length);
-    Vector<BaseFloat> filter(filter_length);
-    signal.SetRandn();
-    filter.SetRandn();
-    Vector<BaseFloat> signal_test(signal);
-    FFTbasedConvolveSignals(filter, &signal_test);
-    FFTbasedBlockConvolveSignals(filter, &signal);
-    AssertEqual(signal, signal_test, 0.000001 * signal.Dim());
-  }
-}
-
-void UnitTestConvolution() {
-  for (int32 i = 0; i < 5; i++) {
-    int32 signal_length = 40000 + Rand() % 4000;
-    int32 filter_length = 100 + Rand() % 100;
-    Vector<BaseFloat> signal(signal_length);
-    Vector<BaseFloat> filter(filter_length);
-    signal.SetRandn();
-    filter.SetRandn();
-    Vector<BaseFloat> signal_test(signal);
-    ConvolveSignals(filter, &signal_test);
-    FFTbasedBlockConvolveSignals(filter, &signal);
-    AssertEqual(signal, signal_test, 0.0001 * signal.Dim());
-  }
-}
-}
-
-int main() {
-  using namespace kaldi;
-  UnitTestBlockConvolution();
-  UnitTestConvolution();
-  KALDI_LOG << "Tests succeeded.";
-
-}
diff --git src/feat/sinusoid-detection-test.cc src/feat/sinusoid-detection-test.cc
deleted file mode 100644
index 68148b4..0000000
--- src/feat/sinusoid-detection-test.cc
+++ /dev/null
@@ -1,452 +0,0 @@
-// feat/sinusoid-detection-test.cc
-
-// Copyright    2015  Johns Hopkins University (author: Daniel Povey)
-
-// See ../../COPYING for clarification regarding multiple authors
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//  http://www.apache.org/licenses/LICENSE-2.0
-//
-// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
-// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
-// MERCHANTABLITY OR NON-INFRINGEMENT.
-// See the Apache 2 License for the specific language governing permissions and
-// limitations under the License.
-
-
-#include <iostream>
-
-#include "base/kaldi-math.h"
-#include "feat/sinusoid-detection.h"
-
-
-namespace kaldi {
-
-// this function is used for testing AddSinusoid.
-void AddSinusoidSimple(BaseFloat samp_freq,
-                       const Sinusoid &sinusoid,
-                       VectorBase<BaseFloat> *signal) {
-  for (int32 i = 0; i < signal->Dim(); i++)
-    (*signal)(i) += sinusoid.amplitude *
-        cos(M_2PI * sinusoid.freq / samp_freq * i + sinusoid.phase);
-}
-
-void UnitTestAddSinusoid() {
-  BaseFloat samp_freq = 560.1;
-  int32 length = 511;
-  Vector<BaseFloat> orig(length);
-  orig.SetRandn();
-  Vector<BaseFloat> orig2(orig);
-  Sinusoid sinusoid(49.20, 2.111, 1.5);
-
-  AddSinusoid(samp_freq, sinusoid, &orig);
-  AddSinusoidSimple(samp_freq, sinusoid, &orig2);
-  AssertEqual(orig, orig2);
-}
-      
-
-
-void UnitTestQuadraticMaximizeEqualSpaced() {
-  for (int32 n = 0; n < 50; n++) {
-  
-    //  Let the cubic function be y = a x^2 + b x + c, and let
-    //   y0,y1,y2 be its values evaluated at x = [0, 1, 2]; we
-    // want it evaluated at arbitrary x.
-    
-    BaseFloat  a = -0.5 + RandUniform(), b = -0.5 + RandUniform(), c = -0.5 + RandUniform();
-    BaseFloat y[3];
-    for (int32 i = 0; i < 3; i++) {
-      BaseFloat x = i;
-      y[i] = a * x * x + b * x + c;
-    }
-    BaseFloat x_max, y_max;
-    SinusoidDetector::QuadraticMaximizeEqualSpaced(y[0], y[1], y[2], &x_max, &y_max);
-
-    for (int32 m = 0; m <= 10; m++) {
-      BaseFloat x_test = 0.1 * m;
-      BaseFloat y_test = a * x_test * x_test + b * x_test + c;
-      KALDI_ASSERT(y_test <= y_max + 1.0e-05);
-    }
-  }
-}
-
-void UnitTestQuadraticMaximize() {
-  for (int32 n = 0; n < 50; n++) {
-  
-    //  Let the cubic function be y = a x^2 + b x + c, and let
-    //   y0,y1,y2 be its values evaluated at x = [0, 1, 2]; we
-    // want it evaluated at arbitrary x.
-    
-    BaseFloat  a = -0.5 + RandUniform(), b = -0.5 + RandUniform(), c = -0.5 + RandUniform(),
-        x = 0.1 + RandUniform() * 0.98;
-    BaseFloat y[3];
-    for (int32 i = 0; i < 3; i++) {
-      BaseFloat this_x;
-      if (i == 0) { this_x = 0.0; }
-      else if (i == 1) { this_x = x; }
-      else { this_x = 1.0; }
-      y[i] = a * this_x * this_x + b * this_x + c;
-    }
-    BaseFloat x_max, y_max;
-    SinusoidDetector::QuadraticMaximize(x, y[0], y[1], y[2], &x_max, &y_max);
-    
-    for (int32 m = 0; m <= 10; m++) {
-      BaseFloat x_test = 0.1 * m;
-      BaseFloat y_test = a * x_test * x_test + b * x_test + c;
-      if (n < 100 && m == 5) {
-        KALDI_VLOG(2) << "Checking y_test <= y_max: "
-                      << y_test << " <= " << y_max << " [x_max = "
-                      << x_max << "]";
-        KALDI_ASSERT(y_test <= y_max + 1.0e-05);
-      }
-    }
-  }
-}
-
-
-void UnitTestSinusoidDetector() {
-  BaseFloat samp_freq = 4000 + (rand() % 2000);
-  int32 num_samp = 128 + rand() % 400;
-  SinusoidDetector detector(samp_freq, num_samp);
-
-  for (int32 i = 0; i < 40; i++) {
-  
-    Vector<BaseFloat> signal(num_samp);
-
-    // Sinusoid ref_sinusoid(1.3, 312.5, M_PI * 0.0);
-    // Sinusoid ref_sinusoid(1.3, 324.125, M_PI * 0.5);
-
-    BaseFloat nyquist = samp_freq * 0.5;
-    BaseFloat freq = nyquist * RandUniform();
-    BaseFloat amplitude = RandUniform();
-    BaseFloat phase = M_2PI * RandUniform();
-
-    Sinusoid ref_sinusoid(amplitude, freq, phase);
-  
-    AddSinusoid(samp_freq, ref_sinusoid, &signal);
-
-
-    BaseFloat orig_energy = VecVec(signal, signal);
-    KALDI_LOG << "Real frequency is " << freq << ", amplitude "
-              << amplitude << ", phase " << phase << ", samp-freq "
-              << samp_freq;
-    KALDI_LOG << "Total energy of signal (with sinusoid) is " << orig_energy;
-  
-    Sinusoid sinusoid;
-    BaseFloat min_energy = 0.0;
-    BaseFloat energy = detector.DetectSinusoid(min_energy,
-                                               signal, &sinusoid);
-
-    Vector<BaseFloat> new_signal(signal);
-    sinusoid.phase += M_PI;  // Reverse the phase.
-    AddSinusoid(samp_freq, sinusoid, &new_signal);
-    BaseFloat delta_energy = VecVec(signal, signal) -
-        VecVec(new_signal, new_signal);
-    KALDI_LOG << "Projected delta energy = " << energy
-              << " and observed was " << delta_energy;
-
-    BaseFloat remaining_energy = VecVec(new_signal, new_signal);
-    if (remaining_energy > 0.01 * orig_energy) {
-      KALDI_WARN << "Energy remaining is " << remaining_energy
-                 << " vs. original " << orig_energy;
-      BaseFloat relative_freq = freq / nyquist;
-      BaseFloat inv_num_samp = 1.0 / num_samp;
-      // We only tolerate this kind of error for very ridiculous frequency,
-      // close to zero or the Nyquist.
-      KALDI_ASSERT(relative_freq < inv_num_samp ||
-                   relative_freq > 1.0 - inv_num_samp);
-    }
-  }
-}
-
-// as UnitTestSinusoidDetector(), but doing it in noisy signals.
-void UnitTestSinusoidDetectorNoisy() {
-  BaseFloat samp_freq = 4000 + (rand() % 2000);
-  int32 num_samp = 128 + rand() % 400;
-  SinusoidDetector detector(samp_freq, num_samp);
-
-  for (int32 i = 0; i < 40; i++) {
-  
-    Vector<BaseFloat> signal(num_samp);
-
-    signal.SetRandn();
-
-    BaseFloat rand_energy = VecVec(signal, signal);
-    
-    // Sinusoid ref_sinusoid(1.3, 312.5, M_PI * 0.0);
-    // Sinusoid ref_sinusoid(1.3, 324.125, M_PI * 0.5);
-
-    BaseFloat nyquist = samp_freq * 0.5;
-    BaseFloat freq = nyquist * RandUniform();
-    BaseFloat amplitude = 10.0 * RandUniform();
-    BaseFloat phase = M_2PI * RandUniform();
-
-    Sinusoid ref_sinusoid(amplitude, freq, phase);
-  
-    AddSinusoid(samp_freq, ref_sinusoid, &signal);
-
-    BaseFloat tot_energy = VecVec(signal, signal);
-
-    KALDI_LOG << "Real frequency is " << freq << ", amplitude "
-              << amplitude << ", phase " << phase << ", samp-freq "
-              << samp_freq;
-    KALDI_LOG << "Total energy of signal (with noise + sinusoid) is " << tot_energy;
-  
-    Sinusoid sinusoid;
-    BaseFloat min_energy = 0.0;
-    BaseFloat energy = detector.DetectSinusoid(min_energy,
-                                               signal, &sinusoid);
-
-    Vector<BaseFloat> new_signal(signal);
-    sinusoid.phase += M_PI;  // reverse the phase.
-    AddSinusoid(samp_freq, sinusoid, &new_signal);
-    BaseFloat delta_energy = VecVec(signal, signal) -
-        VecVec(new_signal, new_signal);
-    KALDI_LOG << "Projected delta energy = " << energy
-              << " and observed was " << delta_energy;
-
-    BaseFloat min_energy_diff = 0.99 * (tot_energy - rand_energy);
-    
-    if (delta_energy < min_energy_diff) {
-      KALDI_WARN << "Energy reduction is " << delta_energy
-                 << " vs. expected " << (tot_energy - rand_energy);
-      BaseFloat relative_freq = freq / nyquist;
-      BaseFloat inv_num_samp = 1.0 / num_samp;
-      // We only tolerate this kind of error for very ridiculous frequency,
-      // close to zero or the Nyquist.
-      KALDI_ASSERT(relative_freq < inv_num_samp ||
-                   relative_freq > 1.0 - inv_num_samp);
-    }
-  }
-}
-
-
-void AddFreqToSignal(BaseFloat base_freq,
-                     BaseFloat samp_freq,
-                     BaseFloat tolerance,
-                     BaseFloat gain,
-                     VectorBase<BaseFloat> *signal) {
-  BaseFloat error_scale = (2 * RandUniform() - 1) * tolerance;
-  BaseFloat freq = base_freq * (1.0 + error_scale);
-  KALDI_VLOG(3) << "base-freq = " << base_freq << ", factor = " << error_scale;
-  for (int32 i = 0; i < signal->Dim(); i++)
-    (*signal)(i) += gain * sin(i * 2.0 * 3.14159 * freq / samp_freq);
-}
-
-
-void GenerateDtmfTestCase(
-    BaseFloat sampling_rate,
-    Vector<BaseFloat> *signal,
-    std::vector<MultiSinusoidDetectorOutput> *ref_output) {
-  // the "ref_output" should correlate with the first of each run of frames with the same label.
-  
-  BaseFloat min_duration_secs = 0.04;  // min duration of dtmf or non-tone segments.
-  BaseFloat min_dialtone_duration_secs = 0.1;
-  BaseFloat frequency_tolerance = 0.035;
-  BaseFloat dialtone_frequency_tolerance = 0.4 * (440.0  - 425.0) / 440.0;
-
-  int32 num_events = 2 * (5 + rand() % 5) + 1; // odd number.
-  int32 tot_signal_dim = 0;
-
-  ref_output->resize(num_events);
-  std::vector<Vector<BaseFloat> > all_signals(num_events);
-  for (int32 i = 0; i < num_events; i++) {
-    MultiSinusoidDetectorOutput &this_output = (*ref_output)[i];
-    Vector<BaseFloat> &this_signal = all_signals[i];
-    BaseFloat duration_secs = min_duration_secs * (1 + rand() % 3);
-    int32 num_samp = sampling_rate * duration_secs;
-    tot_signal_dim += num_samp;
-
-    this_signal.Resize(num_samp);
-    this_signal.SetRandn();
-    
-    if (i % 2 == 0); // do nothing;
-    else if (rand() % 2 == 0 && duration_secs >= min_dialtone_duration_secs) {
-      // dialtone.
-      BaseFloat freq;
-      if (rand() % 3 == 0) { freq = 350; }
-      else if (rand() % 2 == 0) { freq = 440; }
-      else { freq = 425; }
-      BaseFloat gain = 10.0 * (1.0 + rand() % 2);
-      AddFreqToSignal(freq, sampling_rate, dialtone_frequency_tolerance,
-                      gain, &(this_signal));
-      this_output.freq1 = freq;
-    } else {
-      // dtmf.  use a subset of tones as examples.
-      BaseFloat freq1, freq2;
-      char c;
-      if (rand() % 4 == 0) {
-        c = '8'; freq1 = 852; freq2 = 1336;
-      } else if (rand() % 3 == 0) {
-        c = '0'; freq1 = 941; freq2 = 1336;
-      } else if (rand() % 2 == 0) {
-        c = '#'; freq1 = 941; freq2 = 1477;
-      } else {
-        c = '1'; freq1 = 697; freq2 = 1209;
-      }
-      BaseFloat base_gain = 10.0 * (1.0 +  (rand() % 3)),
-          gain_factor = 1.0 + 0.1 * (-2 + rand() % 5),
-          gain1 = base_gain, gain2 = gain_factor * base_gain;
-      AddFreqToSignal(freq1, sampling_rate, frequency_tolerance, gain1,
-                      &(this_signal));
-      AddFreqToSignal(freq2, sampling_rate, frequency_tolerance, gain2,
-                      &(this_signal));
-      this_output.freq1 = freq1;
-      this_output.freq2 = freq2;
-    }
-  }
-  signal->Resize(tot_signal_dim);
-  int32 signal_offset = 0;
-  for (int32 i = 0; i < num_events; i++) {
-    int32 this_dim = all_signals[i].Dim();
-    signal->Range(signal_offset, this_dim).CopyFromVec(all_signals[i]);
-    signal_offset += this_dim;
-  }
-}
-
-
-/*
-
-// Just a basic test to check that it produces output.
-
-void UnitTestToneDetection() {
-  BaseFloat samp_freq = (rand() % 2) == 0 ? 8000 : 16000;
-  ToneDetectionConfig config;
-  
-  int32 num_frames = 100 + (rand() % 100);
-  int32 frame_length = static_cast<int32>(samp_freq * config.frame_length_secs);
-
-  int32 num_samples = frame_length * num_frames + rand() % frame_length;
-  Vector<BaseFloat> signal(num_samples);
-  signal.SetRandn();
-
-  ToneDetector tone_detector(config, samp_freq);
-
-  int32 signal_offset = 0;
-
-  std::vector<ToneDetectorOutput*> tone_detector_output;
-  
-  while (signal_offset < num_samples) {
-    int32 signal_remaining = num_samples - signal_offset,
-        chunk_size = std::min<int32>((rand() % 200) + 100,
-                                     signal_remaining);
-    SubVector<BaseFloat> signal_part(signal, signal_offset, chunk_size);
-    tone_detector.AcceptWaveform(signal_part);
-    signal_offset += chunk_size;
-
-    if (signal_offset == num_samples)
-      tone_detector.WaveformFinished();
-    while (!tone_detector.Done() &&
-           (rand() % 2 == 0 || signal_offset == num_samples)) {
-      ToneDetectorOutput *output = new ToneDetectorOutput();
-      tone_detector.GetNextFrame(output);
-      tone_detector_output.push_back(output);
-    }
-  }
-  KALDI_ASSERT(signal_offset == num_samples);  
-  
-  Vector<BaseFloat> signal2(signal.Dim());
-  signal_offset = 0;
-  for (int32 i = 0; i < tone_detector_output.size(); i++) {
-    ToneDetectorOutput *output = tone_detector_output[i];
-    signal2.Range(signal_offset,
-                  output->signal.Dim()).CopyFromVec(output->signal);
-    signal_offset += output->signal.Dim();
-    if (output->frame_type != 'n') {
-      KALDI_ERR << "Frame " << i << " badly classified, should be 'n', is: "
-                << output->frame_type;
-    }
-    delete output;
-  }
-  KALDI_ASSERT(signal_offset == num_samples &&
-               signal.ApproxEqual(signal2, 1.0e-10));
-
-}
-
-std::ostringstream & operator << (std::ostringstream &ostr,
-             const ToneDetectorOutput &output) {
-  ostr << output.frame_type;
-  if (output.frame_type == 'd')
-    ostr << output.dialtone_freq;
-  ostr << ' ';
-  return ostr;
-}
-
-*/
-
-
-// This version of the unit-test generates a signal that has tones in it, and
-// runs the detection on that signal.
-void UnitTestToneDetection2() {
-  BaseFloat samp_freq = (rand() % 2) == 0 ? 8000 : 16000;
-  Vector<BaseFloat> signal;
-  std::vector<MultiSinusoidDetectorOutput> ref_output;
-  GenerateDtmfTestCase(samp_freq, &signal, &ref_output);
-  
-  MultiSinusoidDetectorConfig config;
-
-  int32 num_samples = signal.Dim();
-  KALDI_ASSERT(num_samples > 0);
-
-  MultiSinusoidDetector multi_sinusoid_detector(config, samp_freq);
-  
-  int32 signal_offset = 0;
-
-  std::vector<MultiSinusoidDetectorOutput*> multi_sinusoid_detector_output;
-
-  while (signal_offset < num_samples) {
-    int32 signal_remaining = num_samples - signal_offset,
-        chunk_size = std::min<int32>((rand() % 200) + 100,
-                                     signal_remaining);
-    SubVector<BaseFloat> signal_part(signal, signal_offset, chunk_size);
-    multi_sinusoid_detector.AcceptWaveform(signal_part);
-    signal_offset += chunk_size;
-
-    if (signal_offset == num_samples)
-      multi_sinusoid_detector.WaveformFinished();
-    while (!multi_sinusoid_detector.Done() &&
-           (rand() % 2 == 0 || signal_offset == num_samples)) {
-      MultiSinusoidDetectorOutput *output = new MultiSinusoidDetectorOutput();
-      multi_sinusoid_detector.GetNextFrame(output);
-      multi_sinusoid_detector_output.push_back(output);
-    }
-  }
-  KALDI_ASSERT(signal_offset == num_samples);  
-  
-  // std::ostringstream str_ref, str_hyp;
-  //for (size_t i = 0; i < ref_output.size(); i++)
-  //    str_ref << ref_output[i];
-
-
-  for (size_t i = 0; i < multi_sinusoid_detector_output.size(); i++) {
-    MultiSinusoidDetectorOutput *output = multi_sinusoid_detector_output[i];
-    KALDI_LOG << "tot-energy = " << output->tot_energy
-              << ", freq1 " << output->freq1 << ", energy1 " << output->energy1
-              << ", freq2 " << output->freq2 << ", energy2 " << output->energy2;
-    delete output;
-  }
-}
-
-
-
-}  // namespace kaldi
-
-int main() {
-  using namespace kaldi;
-
-  SetVerboseLevel(4);
-
-  UnitTestToneDetection2();  
-  UnitTestAddSinusoid();
-  UnitTestQuadraticMaximizeEqualSpaced();
-  UnitTestQuadraticMaximize();
-  for (int32 i = 0; i < 10; i++) {
-    UnitTestSinusoidDetector();
-    UnitTestSinusoidDetectorNoisy();
-  }
-
-}
diff --git src/makefiles/darwin_10_10.mk src/makefiles/darwin_10_10.mk
index 4314397..f13befa 100644
--- src/makefiles/darwin_10_10.mk
+++ src/makefiles/darwin_10_10.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_10.mk contains Darwin-specific rules for OS X 10.10.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -g # -O0 -DKALDI_PARANOID
 
@@ -21,7 +20,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = $(CXX)
 RANLIB = ranlib
@@ -33,10 +32,10 @@ COMPILER = $(shell $(CXX) -v 2>&1 )
 ifeq ($(findstring clang,$(COMPILER)),clang)
   CXXFLAGS += -Wno-mismatched-tags
   # Link with libstdc++ if we are building against OpenFst < 1.4
-  ifneq ("$(OPENFST_GE_10400)","1")
-    CXXFLAGS += -stdlib=libstdc++
-    LDFLAGS += -stdlib=libstdc++
-  endif
+#  ifneq ("$(OPENFST_GE_10400)","1")
+#    CXXFLAGS += -stdlib=libstdc++
+#    LDFLAGS += -stdlib=libstdc++
+#  endif
 endif
 
 # We need to tell recent versions of g++ to allow vector conversions without
diff --git src/makefiles/darwin_10_11.mk src/makefiles/darwin_10_11.mk
index 407ced6..1dcec2d 100644
--- src/makefiles/darwin_10_11.mk
+++ src/makefiles/darwin_10_11.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_11.mk contains Darwin-specific rules for OS X 10.11.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) -Wno-unused-local-typedef \
       -g # -O0 -DKALDI_PARANOID
 
@@ -21,7 +20,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = $(CXX)
 RANLIB = ranlib
@@ -33,10 +32,6 @@ COMPILER = $(shell $(CXX) -v 2>&1 )
 ifeq ($(findstring clang,$(COMPILER)),clang)
   CXXFLAGS += -Wno-mismatched-tags
   # Link with libstdc++ if we are building against OpenFst < 1.4
-  ifneq ("$(OPENFST_GE_10400)","1")
-    CXXFLAGS += -stdlib=libstdc++
-    LDFLAGS += -stdlib=libstdc++
-  endif
 endif
 
 # We need to tell recent versions of g++ to allow vector conversions without
diff --git src/makefiles/darwin_10_5.mk src/makefiles/darwin_10_5.mk
index 5a1353b..9c2456a 100644
--- src/makefiles/darwin_10_5.mk
+++ src/makefiles/darwin_10_5.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_5.mk contains Darwin-specific rules for OS X 10.5.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -gdwarf-2 # -O0 -DKALDI_PARANOID
 
@@ -20,7 +19,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -gdwarf-2
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++-4
 CC = g++-4
 RANLIB = ranlib
diff --git src/makefiles/darwin_10_6.mk src/makefiles/darwin_10_6.mk
index 1a39602..269fb5c 100644
--- src/makefiles/darwin_10_6.mk
+++ src/makefiles/darwin_10_6.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_6.mk contains Darwin-specific rules for OS X 10.6.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H -rdynamic \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -g # -O0 -DKALDI_PARANOID
 
@@ -20,7 +19,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g -rdynamic
-LDLIBS =  $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS =  $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = g++
 RANLIB = ranlib
diff --git src/makefiles/darwin_10_7.mk src/makefiles/darwin_10_7.mk
index 40804af..ec54373 100644
--- src/makefiles/darwin_10_7.mk
+++ src/makefiles/darwin_10_7.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_6.mk contains Darwin-specific rules for OS X 10.7.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H -rdynamic \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -g # -O0 -DKALDI_PARANOID
 
@@ -21,7 +20,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g -rdynamic
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = g++
 RANLIB = ranlib
diff --git src/makefiles/darwin_10_8.mk src/makefiles/darwin_10_8.mk
index 7fd3bb0..1b7aac9 100644
--- src/makefiles/darwin_10_8.mk
+++ src/makefiles/darwin_10_8.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_8.mk contains Darwin-specific rules for OS X 10.8.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H -rdynamic \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -g # -O0 -DKALDI_PARANOID
 
@@ -21,7 +20,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g -rdynamic
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = g++
 RANLIB = ranlib
diff --git src/makefiles/darwin_10_9.mk src/makefiles/darwin_10_9.mk
index 6477a60..dac13cb 100644
--- src/makefiles/darwin_10_9.mk
+++ src/makefiles/darwin_10_9.mk
@@ -1,8 +1,8 @@
 # makefiles/darwin_10_9.mk contains Darwin-specific rules for OS X 10.9.*
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 DOUBLE_PRECISION = 0
 CXXFLAGS += -msse -msse2 -Wall -I.. \
@@ -11,7 +11,6 @@ CXXFLAGS += -msse -msse2 -Wall -I.. \
       -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -DHAVE_CXXABI_H \
       -DHAVE_CLAPACK \
-      -I$(FSTROOT)/include \
       $(EXTRA_CXXFLAGS) \
       -g # -O0 -DKALDI_PARANOID
 
@@ -21,7 +20,7 @@ CXXFLAGS += -fPIC
 endif
 
 LDFLAGS = -g
-LDLIBS = $(EXTRA_LDLIBS) $(FSTROOT)/lib/libfst.a -ldl -lm -lpthread -framework Accelerate
+LDLIBS = $(EXTRA_LDLIBS) -ldl -lm -lpthread -framework Accelerate
 CXX = g++
 CC = $(CXX)
 RANLIB = ranlib
diff --git src/makefiles/default_rules.mk src/makefiles/default_rules.mk
index 3d3f963..6f43915 100644
--- src/makefiles/default_rules.mk
+++ src/makefiles/default_rules.mk
@@ -37,12 +37,12 @@ $(LIBFILE): $(OBJFILES)
 ifeq ($(KALDI_FLAVOR), dynamic)
 ifeq ($(shell uname), Darwin)
 	$(CXX) -dynamiclib -o $@ -install_name @rpath/$@ -framework Accelerate $(LDFLAGS) $(XLDLIBS) $(OBJFILES) $(LDLIBS)
-	rm -f $(KALDILIBDIR)/$@; ln -s $(shell pwd)/$@ $(KALDILIBDIR)/$@
+	rm -f $(KALDILIBDIR)/$@; cp -f $(shell pwd)/$@ $(KALDILIBDIR)/$@
 else
 ifeq ($(shell uname), Linux)
 	# Building shared library from static (static was compiled with -fPIC)
 	$(CXX) -shared -o $@ -Wl,--no-undefined -Wl,--as-needed  -Wl,-soname=$@,--whole-archive $(LIBNAME).a -Wl,--no-whole-archive  $(LDFLAGS) $(XDEPENDS) $(LDLIBS)
-	rm -f $(KALDILIBDIR)/$@; ln -s $(shell pwd)/$@ $(KALDILIBDIR)/$@
+	rm -f $(KALDILIBDIR)/$@; cp -f $(shell pwd)/$@ $(KALDILIBDIR)/$@
 	#cp $@ $(KALDILIBDIR)
 else  # Platform not supported
 	$(error Dynamic libraries not supported on this platform. Run configure with --static flag. )
diff --git src/makefiles/linux_openblas.mk src/makefiles/linux_openblas.mk
index b910d82..52dca7a 100644
--- src/makefiles/linux_openblas.mk
+++ src/makefiles/linux_openblas.mk
@@ -1,8 +1,8 @@
 # You have to make sure FSTROOT,OPENBLASROOT,OPENBLASLIBS are set...
 
-ifndef FSTROOT
-$(error FSTROOT not defined.)
-endif
+#ifndef FSTROOT
+#$(error FSTROOT not defined.)
+#endif
 
 ifndef OPENBLASLIBS
 $(error OPENBLASLIBS not defined.)
@@ -17,19 +17,18 @@ DOUBLE_PRECISION = 0
 CXXFLAGS = -msse -msse2 -Wall -I.. \
            -pthread \
       -DKALDI_DOUBLEPRECISION=$(DOUBLE_PRECISION) -DHAVE_POSIX_MEMALIGN \
-      -Wno-sign-compare -Wno-unused-local-typedefs -Winit-self \
+      -Wno-sign-compare -Winit-self \
       -DHAVE_EXECINFO_H=1 -rdynamic -DHAVE_CXXABI_H \
       -DHAVE_OPENBLAS -I $(OPENBLASROOT)/include \
-      -I $(FSTROOT)/include \
-      $(EXTRA_CXXFLAGS) \
-      -g # -O0 -DKALDI_PARANOID 
+      $(EXTRA_CXXFLAGS) -Wabi-tag \
+      -g -D_GLIBCXX_USE_CXX11_ABI=0 # -O0 -DKALDI_PARANOID 
 
 ifeq ($(KALDI_FLAVOR), dynamic)
 CXXFLAGS += -fPIC
 endif
 
-LDFLAGS = -rdynamic $(OPENFSTLDFLAGS)
-LDLIBS = $(EXTRA_LDLIBS) $(OPENFSTLIBS) $(OPENBLASLIBS) -lm -lpthread -ldl 
+LDFLAGS = -rdynamic
+LDLIBS = $(EXTRA_LDLIBS) $(OPENBLASLIBS) -lm -lpthread -ldl 
 CC = g++
 CXX = g++
 AR = ar
